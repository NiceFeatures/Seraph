<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seraph Defesa Final</title>
    <link rel="icon" type="image/png" href="img/icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        background-color: #000;
        color: #fff;
        font-family: "Press Start 2P", Courier, monospace;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        background-color: #000;
        display: block;
      }
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 50;
        text-align: center;
        overflow-y: auto;
        padding: 20px 0;
      }
      #splashScreen {
        background-color: #000;
        z-index: 100;
      }
      .splash-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .splash-options-row {
        display: flex;
        gap: 20px;
        margin-top: 0;
      }
      .run-summary {
        font-size: 1.1em;
        line-height: 1.8;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border: 1px solid #f1c40f;
        margin-bottom: 30px;
        text-align: left;
        max-width: 600px;
      }
      .run-summary h3 {
        color: #00ffff;
        margin-top: 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #00ffff;
        padding-bottom: 5px;
      }
      #wikiScreen {
        display: none;
        flex-direction: column;
      }
      #wikiSearchBox {
        width: 80%;
        max-width: 600px;
        padding: 10px;
        margin-bottom: 20px;
        background-color: #111;
        border: 2px solid #555;
        color: #fff;
        font-family: "Press Start 2P", Courier, monospace;
        font-size: 0.8em;
      }
      .wiki-list {
        width: 90%;
        max-width: 800px;
        max-height: 70vh;
        overflow-y: auto;
        border: 2px solid #555;
        padding: 15px;
        background: rgba(0, 0, 0, 0.5);
        margin-bottom: 20px;
      }
      .wiki-item {
        padding: 15px;
        border-bottom: 1px dotted #444;
      }
      .wiki-item:last-child {
        border-bottom: none;
      }
      .wiki-item h3 {
        margin: 0 0 5px 0;
        font-size: 1.2em;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .wiki-item p {
        margin: 0 0 10px 0;
        color: #ccc;
        font-family: "Courier New", Courier, monospace;
      }
      .wiki-item .rarity {
        font-size: 0.8em;
        font-weight: bold;
        text-transform: uppercase;
      }
      #dev-controls {
        display: flex;
        gap: 10px;
        margin-top: 0;
      }
      #splashScreen h1 {
        margin-bottom: 50px;
      }
      .splash-divider {
        width: 80%;
        max-width: 500px;
        border: 0;
        height: 1px;
        background-image: linear-gradient(
          to right,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0.2),
          rgba(255, 255, 255, 0)
        );
        margin: 25px 0 15px;
      }
      .splash-section-title {
        font-size: 1em;
        color: #ccc;
        margin: 0 0 10px;
        font-weight: 400;
      }
      #dev-controls .btn {
        font-size: 0.7em;
        padding: 8px 12px;
      }
      #resetProgressButton {
        border-color: #c0392b;
        color: #c0392b;
      }
      #splashScreen h1,
      #gameOverTitle,
      #pauseTitle {
        font-size: 4em;
        text-shadow: 2px 2px 10px #ff00ff;
        margin-bottom: 20px;
        line-height: 1.2;
      }
      #splashScreen p {
        font-size: 1em;
        margin-bottom: 40px;
        color: #ccc;
        line-height: 1.5;
      }
      .btn,
      #splashScreen button,
      #restartButton,
      #resumeButton,
      #restartFromPauseButton {
        padding: 15px 30px;
        font-size: 1.2em;
        cursor: pointer;
        background-color: #000;
        color: #fff;
        border: 2px solid #fff;
        transition: background-color 0.2s, color 0.2s;
        margin: 10px;
        font-family: "Press Start 2P", Courier, monospace;
      }
      .btn:hover,
      #splashScreen button:hover,
      #restartButton:hover,
      #resumeButton:hover,
      #restartFromPauseButton:hover {
        background-color: #fff;
        color: #000;
      }
      #top-ui-container {
        position: absolute;
        top: 10px;
        left: 0;
        width: 100%;
        z-index: 10;
      }
      #exp-bar-container {
        width: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 0;
        box-shadow: none;
        margin: 0;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #exp-bar.full {
        background-color: #3498db;
        box-shadow: 0 0 8px #3498db, inset 0 0 5px rgba(255, 255, 255, 0.3);
        animation: none;
      }
      #left-ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        text-shadow: 1px 1px 3px #000;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        pointer-events: none;
      }
      #game-info-text {
        font-size: 1.5em;
        color: #fff;
        margin-bottom: 10px;
      }
      #score-text {
        font-size: 1.2em;
        color: #f1c40f;
      }
      #timer-text {
        font-size: 1.2em;
        color: #fff;
        margin-top: 5px;
      }
      #enemy-count-text {
        font-size: 1em;
        color: #bbb;
        margin-top: 8px;
      }
      #soul-popup {
        position: absolute;
        bottom: 10px;
        left: 20px;
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.3);
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #add8e6;
        color: #add8e6;
        font-size: 1.1em;
        font-weight: 700;
        text-shadow: 1px 1px 3px #000;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }
      #soul-popup.active {
        opacity: 1;
      }
      .bar-container {
        width: 100%;
        background-color: rgba(0, 0, 0, 0.2);
        margin-bottom: 10px;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.4);
      }
      @keyframes shimmer {
        0% {
          background-position: -100% 0;
        }
        100% {
          background-position: 100% 0;
        }
      }
      @keyframes liquid-flow {
        0% {
          background-position: -200% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }
      .bar {
        height: 10px;
        transition: width 0.5s ease-out;
        position: relative;
        overflow: hidden;
      }
      .bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0) 0,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0) 100%
        );
        background-size: 200% 100%;
        animation: shimmer 2s linear infinite;
      }
      #exp-bar {
        background-color: #2ecc71;
        box-shadow: 0 0 5px #2ecc71, inset 0 0 5px rgba(255, 255, 255, 0.2);
        background-image: linear-gradient(
          90deg,
          transparent 25%,
          rgba(255, 255, 255, 0.2) 50%,
          transparent 75%,
          transparent 100%
        );
        background-size: 200% 100%;
        animation: liquid-flow 3s linear infinite;
      }
      @keyframes background-pan {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 400% 400%;
        }
      }
      @keyframes flash-effect {
        0%,
        100% {
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }
      #levelUpFlash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at center,
          rgba(255, 255, 220, 0.8) 0,
          rgba(255, 255, 220, 0) 70%
        );
        opacity: 0;
        pointer-events: none;
        z-index: 999;
      }
      #levelUpFlash.active {
        animation: flash-effect 0.8s ease-out;
      }
      #gameOverScreen,
      #levelUpScreen,
      #pauseScreen,
      #splashHatShopScreen,
      #leaderboardScreen {
        display: none;
      }
      #levelUpScreen {
        background-color: #01011a;
        background-image: radial-gradient(
            ellipse at 50% 100%,
            rgba(66, 134, 244, 0.4) 0,
            transparent 60%
          ),
          radial-gradient(
            ellipse at 80% 0,
            rgba(0, 255, 255, 0.3) 0,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 20% 0,
            rgba(155, 89, 182, 0.3) 0,
            transparent 50%
          );
        background-size: 400% 400%;
        animation: background-pan 45s linear infinite;
      }
      #levelUpTitle {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-shadow: 2px 2px 8px #00ffff;
      }
      #pauseTitle {
        color: #00ffff;
        text-shadow: 2px 2px 10px #00ffff;
      }
      #upgradeCardsContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 25px;
        margin-bottom: 30px;
      }
      .upgrade-card {
        width: 220px;
        min-height: 280px;
        border: 2px solid;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        background: radial-gradient(ellipse at top, #3a3a3a, #111);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        text-align: center;
      }
      .upgrade-card:hover {
        transform: translateY(-10px) scale(1.05);
      }
      .card-icon {
        width: 100%;
        height: 80px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 15px;
      }
      .card-icon img {
        width: 64px;
        height: 64px;
        image-rendering: pixelated;
      }
      .card-header {
        padding: 10px 15px 15px 15px;
      }
      .card-header h3 {
        margin: 0;
        font-size: 1em;
        color: #fff;
        line-height: 1.4;
      }
      .card-rarity {
        font-size: 0.8em;
        font-weight: 700;
        margin-top: 5px;
        text-transform: uppercase;
        opacity: 0.8;
      }
      .card-divider {
        height: 1px;
        background: linear-gradient(
          to right,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        margin: 0 15px;
      }
      .card-description {
        padding: 20px 15px;
        font-size: 0.8em;
        color: #ddd;
        flex-grow: 1;
        line-height: 1.6;
        font-family: "Courier New", Courier, monospace;
      }
      .rarity-common {
        border-color: #fff;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
      }
      .rarity-common .card-rarity {
        color: #fff;
      }
      .rarity-common:hover {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      }
      .rarity-uncommon {
        border-color: #3498db;
        box-shadow: 0 0 8px rgba(52, 152, 219, 0.7);
      }
      .rarity-uncommon .card-rarity {
        color: #3498db;
      }
      .rarity-uncommon:hover {
        box-shadow: 0 0 20px rgba(52, 152, 219, 1);
      }
      .rarity-rare {
        border-color: #9b59b6;
        box-shadow: 0 0 8px rgba(155, 89, 182, 0.7);
      }
      .rarity-rare .card-rarity {
        color: #9b59b6;
      }
      .rarity-rare:hover {
        box-shadow: 0 0 20px rgba(155, 89, 182, 1);
      }
      #rerollButton {
        padding: 10px 20px;
        font-size: 1.2em;
        cursor: pointer;
        background-color: #000;
        color: #00ffff;
        border: 2px solid #00ffff;
        box-shadow: 0 0 10px #00ffff;
      }
      #rerollButton:disabled {
        color: #555;
        border-color: #555;
        box-shadow: none;
        cursor: not-allowed;
      }
      #waveAnnouncer {
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 4em;
        color: #fff;
        text-shadow: 2px 2px 10px #ff00ff;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      #gameOverTitle {
        color: #c0392b;
        text-shadow: 4px 4px 0 #5c110a;
      }
      #gameOverStats {
        margin-bottom: 20px;
        font-size: 1.2em;
        line-height: 1.6;
      }
      .hat-shop-wrapper {
        margin-top: 20px;
        border-top: 2px solid #555;
        padding-top: 20px;
        width: 80%;
      }
      .hat-shop-wrapper h2 {
        margin-top: 0;
      }
      .hat-shop-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        max-height: 200px;
        overflow-y: auto;
        padding: 0 20px;
      }
      .hat-card {
        background: #222;
        border: 1px solid #444;
        padding: 10px;
        width: 150px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }
      .hat-card canvas {
        background-color: #000;
        border: 1px solid #333;
      }
      .hat-card button {
        width: 100%;
        padding: 5px;
        margin-top: 5px;
        cursor: pointer;
        border: 1px solid #888;
        background-color: #333;
        color: #fff;
      }
      .hat-card button:disabled {
        background: #555;
        color: #888;
        cursor: not-allowed;
      }
      .hat-card button.equipped {
        background: #2ecc71;
        border-color: #27ae60;
        color: #fff;
      }
      .splash-buttons {
        display: flex;
        gap: 20px;
      }
      .splash-options-row .btn {
        font-size: 1em;
        padding: 10px 20px;
      }
      .pause-options-row {
        position: absolute;
        bottom: 15%;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      .pause-options-row .btn {
        margin: 0;
        font-size: 1em;
        padding: 10px 20px;
      }
      #leaderboard {
        background: rgba(0, 0, 0, 0.85);
        border-top: 2px solid #555;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-top: 20px;
      }
      #leaderboard h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboard-list {
        list-style: none;
        padding: 0;
        max-height: 180px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboard-list li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboard-list li span:last-child {
        color: #f1c40f;
      }
      #leaderboard-list li:last-child {
        border: none;
      }
      #score-submission input {
        background: #111;
        border: 1px solid #888;
        color: #fff;
        padding: 8px;
        margin-right: 10px;
        font-family: "Press Start 2P", Courier, monospace;
      }
      #score-submission button {
        padding: 8px 15px;
        font-size: 1em;
      }
      #submission-message {
        margin-top: 10px;
        font-size: 0.9em;
      }
      #submission-message.error {
        color: #e74c3c;
      }
      #leaderboardScreen .leaderboard-container {
        background: rgba(0, 0, 0, 0.85);
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-bottom: 20px;
      }
      #leaderboardScreen h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboardScreen ul {
        list-style: none;
        padding: 0;
        max-height: 300px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboardScreen li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboardScreen li:last-child {
        border: none;
      }
      #leaderboardScreen li span:last-child {
        color: #f1c40f;
      }
      #leaderboardScreen .leaderboard-container {
        background: rgba(0, 0, 0, 0.85);
        padding: 20px;
        width: 90%;
        max-width: 600px;
        margin-bottom: 20px;
      }
      #leaderboardScreen h3 {
        color: #00ffff;
        margin-top: 0;
      }
      #leaderboardScreen ul {
        list-style: none;
        padding: 0;
        max-height: 300px;
        overflow-y: auto;
        text-align: left;
      }
      #leaderboardScreen li {
        display: flex;
        justify-content: space-between;
        padding: 4px;
        border-bottom: 1px dotted #444;
      }
      #leaderboardScreen li:last-child {
        border: none;
      }
      #leaderboardScreen li span:last-child {
        color: #f1c40f;
      }
      #optionsScreen,
      #debugScreen {
        display: none;
      }
      .options-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        margin: 20px 0;
      }
      #right-ui-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 55;
        text-align: right;
        text-shadow: 1px 1px 3px #000;
        opacity: 0.7;
        transition: opacity 0.3s ease-in-out;
        max-height: 40vh;
        overflow-y: auto;
        padding: 5px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
      }
      #autofire-indicator {
        font-size: 1.2em;
        color: #e74c3c;
        margin-bottom: 10px;
      }
      #autofire-indicator.active {
        color: #2ecc71;
      }
      #upgrade-inventory {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 5px;
      }
      inventory-item {
        font-size: 0.6em;
        background: rgba(0, 0, 0, 0.5);
        padding: 3px 6px;
        border-radius: 3px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        display: flex;
        align-items: center;
        gap: 4px;
        margin-bottom: 3px;
      }
      #toggleInventoryButton {
        position: absolute;
        bottom: 30px;
        right: 30px;
        width: 60px;
        height: 60px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        cursor: pointer;
        transition: background-color 0.2s;
        z-index: 51;
      }
      #toggleInventoryButton:hover {
        background-color: rgba(0, 255, 255, 0.2);
      }
      #levelUpScreen #toggleInventoryButton {
        bottom: auto;
        right: auto;
        top: 20px;
        left: 20px;
      }
      #controls-guide {
        position: absolute;
        top: 60vh;
        left: 20px;
        font-size: 0.8em;
        color: #ccc;
        text-shadow: 1px 1px 2px #000;
        line-height: 1.6;
        pointer-events: none;
        z-index: 9;
      }
      #victoryScreen {
        display: none;
        background-color: #0c0a1f;
      }
      #victoryTitle {
        font-size: 4em;
        color: #f1c40f;
        text-shadow: 2px 2px 10px #f1c40f;
        margin-bottom: 20px;
      }
      #victoryStats {
        font-size: 1.1em;
        line-height: 1.8;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border: 1px solid #f1c40f;
        margin-bottom: 30px;
        text-align: left;
        max-width: 600px;
      }
      #victoryStats h3 {
        color: #00ffff;
        margin-top: 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #00ffff;
        padding-bottom: 5px;
      }
      .victory-options {
        display: flex;
        gap: 20px;
      }
    </style>
  </head>
  <body>
    <div id="levelUpFlash"></div>
    <div
      id="sceneTransitionOverlay"
      style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        opacity: 0;
        visibility: hidden;
        z-index: 9998;
        transition: opacity 0.7s ease-in-out, visibility 0s linear 0.7s;
      "
    ></div>

    <div id="splashScreen" class="screen">
      <div class="splash-content-wrapper">
        <h1>Seraph<br />Defesa Final</h1>
        <div class="splash-buttons">
          <button id="goToDifficultyButton">Iniciar Jogo</button>
          <button id="splashHatShopButton">Classes</button>
          <button id="splashLeaderboardButton">Placar</button>
          <button id="splashWikiButton" class="btn">Wiki</button>
        </div>
        <div class="splash-buttons" style="margin-top: 30px">
          <button id="splashOptionsButton" class="btn">Opções</button>
          <button id="splashDebugButton" class="btn">Debug</button>
        </div>
      </div>
    </div>

    <div
      id="difficultyScreen"
      class="screen"
      style="display: none; background-color: #050510"
    >
      <h2>Escolha a Dificuldade</h2>
      <div class="options-container">
        <button id="difficultyEasy" class="btn">Fácil</button>
        <button id="difficultyNormal" class="btn">Normal</button>
        <button id="difficultyHard" class="btn">Difícil</button>
      </div>
      <button id="difficultyBackButton" class="btn" style="margin-top: 30px">
        Voltar
      </button>
    </div>

    <div id="optionsScreen" class="screen">
      <h2>Opções</h2>
      <div class="options-container">
        <button id="aimLineToggle" class="btn">Mira: LIGADA</button>
        <button id="hitboxToggle" class="btn">Hitbox: DESLIGADO</button>
        <button id="enemyHealthToggle" class="btn">Barras HP: LIGADO</button>
        <button id="damageNumbersToggle" class="btn">Nº Dano: LIGADO</button>
        <button id="parallaxToggle" class="btn">Parallax: LIGADO</button>
        <button id="soundToggle" class="btn">Som: LIGADO</button>
        <button id="inventoryToggle" class="btn">Power Ups: LIGADO</button>
      </div>
      <button id="optionsBackButton" class="btn" style="margin-top: 20px">
        Voltar
      </button>
    </div>

    <div id="debugScreen" class="screen">
      <h2>Debug</h2>
      <div class="options-container">
        <button id="unlockAllHatsButton" class="btn">Liberar Classes</button>
        <button id="resetProgressButton" class="btn">Resetar Jogo</button>
      </div>
      <button id="debugBackButton" class="btn" style="margin-top: 20px">
        Voltar
      </button>
    </div>

    <div id="splashHatShopScreen" class="screen">
      <div class="hat-shop-wrapper">
        <h2>
          Classes<br /><span
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 8px;
            "
            ><img src="img/alma.png" style="width: 24px; height: 24px" />
            <span id="splashSoulCount">0</span></span
          >
        </h2>
        <div id="splashHatShopContainer" class="hat-shop-container"></div>
      </div>
      <button id="splashHatShopBackButton" class="btn">Voltar</button>
    </div>

    <div id="leaderboardScreen" class="screen">
      <div class="leaderboard-container">
        <h3>Placar de Líderes</h3>
        <ul id="leaderboard-list-main">
          <li>Carregando...</li>
        </ul>
      </div>
      <button id="clearLeaderboardButton" class="btn">Limpar Placar</button>
      <button id="leaderboardBackButton" class="btn">Voltar</button>
    </div>

    <canvas id="gameCanvas" tabindex="0"></canvas>
    <div id="top-ui-container">
      <div id="exp-bar-container" class="bar-container">
        <div id="exp-bar" class="bar"></div>
        <span
          id="exp-bar-text"
          style="
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7em;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            z-index: 1;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: none;
          "
          >0/0 (0%)</span
        >
      </div>
    </div>

    <div id="left-ui-container">
      <div id="game-info-text">LVL 1 | Onda 0</div>
      <div id="score-text">Placar: 0</div>
      <div id="timer-text">Tempo: 00:00</div>
      <div id="enemy-count-text">Inimigos: 0/0</div>
    </div>

    <div id="controls-guide">
      A/D para Mover<br />Espaço para Pular<br />S para Queda Rápida<br />R para
      Tiro Automático<br />ESC para Pausar<br />Mouse para Mirar<br />Click para
      Atirar<br />U para Ocultar Controles
    </div>

    <div id="soul-popup">
      <img src="img/alma.png" style="width: 24px; height: 24px" />
      <span id="soul-popup-text">: 0</span>
    </div>

    <div id="waveAnnouncer"></div>
    <div id="right-ui-container">
      <div id="autofire-indicator" style="display: none"></div>
      <div id="upgrade-inventory"></div>
    </div>

    <div id="levelUpScreen" class="screen">
      <h2 id="levelUpTitle">NÍVEL ALCANÇADO</h2>
      <div id="upgradeCardsContainer"></div>
      <button id="rerollButton">Rerolar</button>
      <div id="toggleInventoryButton" title="Ver/Ocultar Inventário">👁️</div>
    </div>

    <div id="gameOverScreen" class="screen">
      <h1 id="gameOverTitle">FIM DE JOGO</h1>
      <div id="gameOverStats" class="run-summary"></div>
      <div id="leaderboard">
        <h3>Placar de Líderes</h3>
        <div id="score-submission">
          <input
            type="text"
            id="playerNameInput"
            placeholder="Seu Nome"
            maxlength="20"
          />
          <button id="submitScoreBtn" class="btn">Enviar</button>
        </div>
        <div id="submission-message"></div>
        <ul id="leaderboard-list">
          <li>Carregando...</li>
        </ul>
      </div>
      <button id="restartButton">Jogar Novamente</button>
      <button id="backToMenuButton" class="btn">Voltar ao Início</button>
    </div>

    <div id="pauseScreen" class="screen">
      <h2 id="pauseTitle">PAUSADO</h2>
      <button id="resumeButton">Continuar</button>
      <button id="pauseLeaderboardButton" class="btn">Placar</button>
      <button id="pauseOptionsButton" class="btn">Opções</button>
      <button id="pauseWikiButton" class="btn">Wiki</button>
      <button id="pauseShowControlsButton" class="btn">Atalhos</button>
      <button id="restartFromPauseButton">Reiniciar</button>
      <button id="pauseBackToMenuButton" class="btn">Voltar ao Menu</button>
    </div>

    <div id="victoryScreen" class="screen">
      <h1 id="victoryTitle">VITÓRIA!</h1>
      <div id="victoryStats"></div>
      <div class="victory-options">
        <button id="endRunButton" class="btn">Finalizar Corrida</button>
        <button id="continueButton" class="btn">
          Continuar (Modo Infinito)
        </button>
      </div>
    </div>

    <div id="wikiScreen" class="screen">
      <h2>Wiki de Upgrades</h2>
      <input
        type="text"
        id="wikiSearchBox"
        placeholder="Buscar por nome, raridade ou efeito..."
      />
      <div id="wikiListContainer" class="wiki-list"></div>
      <button id="wikiBackButton" class="btn">Voltar</button>
    </div>
    <script>
      const d = document,
        canvas = d.getElementById("gameCanvas"),
        ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = !1;
      (canvas.width = window.innerWidth), (canvas.height = window.innerHeight);
      const splashScreen = d.getElementById("splashScreen"),
        startButton = d.getElementById("startButton"),
        levelUpScreen = d.getElementById("levelUpScreen"),
        upgradeCardsContainer = d.getElementById("upgradeCardsContainer"),
        rerollButton = d.getElementById("rerollButton"),
        gameOverScreen = d.getElementById("gameOverScreen"),
        restartButton = d.getElementById("restartButton"),
        waveAnnouncer = d.getElementById("waveAnnouncer"),
        pauseScreen = d.getElementById("pauseScreen"),
        resumeButton = d.getElementById("resumeButton"),
        restartFromPauseButton = d.getElementById("restartFromPauseButton"),
        pauseShowControlsButton = d.getElementById("pauseShowControlsButton"),
        splashHatShopButton = d.getElementById("splashHatShopButton"),
        splashHatShopScreen = d.getElementById("splashHatShopScreen"),
        splashHatShopBackButton = d.getElementById("splashHatShopBackButton"),
        leaderboardScreen = d.getElementById("leaderboardScreen"),
        splashLeaderboardButton = d.getElementById("splashLeaderboardButton"),
        pauseLeaderboardButton = d.getElementById("pauseLeaderboardButton"),
        leaderboardBackButton = d.getElementById("leaderboardBackButton"),
        optionsScreen = d.getElementById("optionsScreen"),
        debugScreen = d.getElementById("debugScreen"),
        splashOptionsButton = d.getElementById("splashOptionsButton"),
        splashDebugButton = d.getElementById("splashDebugButton"),
        pauseOptionsButton = d.getElementById("pauseOptionsButton"),
        optionsBackButton = d.getElementById("optionsBackButton"),
        debugBackButton = d.getElementById("debugBackButton"),
        soundToggle = d.getElementById("soundToggle"),
        aimLineToggle = d.getElementById("aimLineToggle"),
        hitboxToggle = d.getElementById("hitboxToggle"),
        enemyHealthToggle = d.getElementById("enemyHealthToggle"),
        damageNumbersToggle = d.getElementById("damageNumbersToggle"),
        parallaxToggle = d.getElementById("parallaxToggle"),
        inventoryToggle = d.getElementById("inventoryToggle"),
        wikiScreen = d.getElementById("wikiScreen"),
        wikiBackButton = d.getElementById("wikiBackButton"),
        splashWikiButton = d.getElementById("splashWikiButton"),
        pauseWikiButton = d.getElementById("pauseWikiButton");
      (goToDifficultyButton = d.getElementById("goToDifficultyButton")),
        (difficultyScreen = d.getElementById("difficultyScreen")),
        (difficultyEasy = d.getElementById("difficultyEasy")),
        (difficultyNormal = d.getElementById("difficultyNormal")),
        (difficultyHard = d.getElementById("difficultyHard")),
        (difficultyCustom = d.getElementById("difficultyCustom")),
        (difficultyBackButton = d.getElementById("difficultyBackButton"));
      const spriteImages = {};
      let wikiReturnScreen = null;
      class SoundManager {
        constructor() {
          this.audioContext = null;
          this.masterGainNode = null;
        }

        init() {
          if (this.audioContext) return;
          try {
            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            this.masterGainNode = this.audioContext.createGain();
            this.masterGainNode.connect(this.audioContext.destination);
            this.masterGainNode.gain.setValueAtTime(
              0.3,
              this.audioContext.currentTime
            );
            if (this.audioContext.state === "suspended") {
              this.audioContext.resume().catch(console.error);
            }
          } catch (e) {
            console.error("Web Audio API is not supported in this browser");
          }
        }

        playSound(freqStart, freqEnd, duration, type = "sine", volume = 0.5) {
          if (!gameData.soundEnabled || !this.audioContext) return;
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const now = this.audioContext.currentTime;

          osc.connect(gain);
          gain.connect(this.masterGainNode);

          osc.type = type;
          osc.frequency.setValueAtTime(freqStart, now);
          osc.frequency.exponentialRampToValueAtTime(
            freqEnd,
            now + duration * 0.8
          );

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + duration * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          osc.start(now);
          osc.stop(now + duration);
        }

        playNoise(duration, filterFreq, volume = 0.5, filterType = "bandpass") {
          if (!gameData.soundEnabled || !this.audioContext) return;
          const bufferSize = this.audioContext.sampleRate * duration;
          const buffer = this.audioContext.createBuffer(
            1,
            bufferSize,
            this.audioContext.sampleRate
          );
          const output = buffer.getChannelData(0);

          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }

          const noise = this.audioContext.createBufferSource();
          noise.buffer = buffer;

          const filter = this.audioContext.createBiquadFilter();
          filter.type = filterType;
          filter.Q.value = 1;
          filter.frequency.value = filterFreq;

          const gain = this.audioContext.createGain();
          const now = this.audioContext.currentTime;

          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.masterGainNode);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + duration * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          noise.start(now);
          noise.stop(now + duration);
        }

        playShootSound() {
          this.playSound(600, 1200, 0.03, "triangle", 0.25);
          this.playSound(1000, 200, 0.07, "square", 0.3);
          this.playNoise(0.06, 2500, 0.1, "highpass");
        }

        playEnemyHitSound() {
          this.playSound(300, 50, 0.15, "sine", 0.4);
          this.playNoise(0.12, 600, 0.3, "bandpass", 0.7);
        }

        playPlayerDamageSound() {
          this.playSound(100, 30, 0.3, "triangle", 0.5);
          this.playNoise(0.35, 200, 0.3, "lowpass");
          this.playNoise(0.2, 3000, 0.15, "highpass");
        }

        playJumpSound() {
          this.playSound(400, 900, 0.15, "sine", 0.3);
          this.playNoise(0.05, 2000, 0.1, "bandpass", 0.8);
        }

        playEnemyDieSound() {
          this.playSound(150, 50, 0.25, "sine", 0.4);
          this.playNoise(0.3, 500, 0.3, "bandpass");
        }

        playCollectOrbSound() {
          this.playSound(800, 1600, 0.1, "triangle", 0.3);
          this.playSound(1200, 2400, 0.1, "sine", 0.2);
        }

        playHealSound() {
          this.playSound(500, 1000, 0.3, "sine", 0.5);
          this.playSound(750, 1500, 0.3, "sine", 0.5);
        }

        playLevelUpSound() {
          this.playSound(100, 1000, 0.4, "sawtooth", 0.4);
          this.playSound(880, 1760, 0.4, "sine", 0.5);
        }

        playDiceRollSound() {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              this.playNoise(0.1, 1000 + Math.random() * 2000, 0.2);
            }, i * 40);
          }
        }

        playUIClickSound() {
          this.playSound(600, 500, 0.1, "square", 0.2);
        }

        playGameOverSound() {
          this.playSound(200, 50, 1, "sawtooth", 0.5);
        }
      }
      const soundManager = new SoundManager();
      const Starfield = {
        stars: [],
        init() {
          this.stars = [];
          const config =
            starfieldConfigs[currentStarfieldConfig % starfieldConfigs.length];
          const e = { near: config.near, mid: config.mid, far: config.far };
          const t = {
            near: {
              size: config.baseSize * 1.2,
              parallax: 0.2,
              colors: config.colors,
            },
            mid: {
              size: config.baseSize,
              parallax: 0.1,
              colors: config.colors,
            },
            far: {
              size: config.baseSize * 0.8,
              parallax: 0.05,
              colors: config.colors,
            },
          };
          for (const o in e) {
            for (let i = 0; i < e[o]; i++) {
              this.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * t[o].size,
                parallax: t[o].parallax,
                color:
                  t[o].colors[Math.floor(Math.random() * t[o].colors.length)],
              });
            }
          }
        },
        update(e) {
          this.stars.forEach((t) => {
            (t.x -= e * t.parallax),
              t.x < 0 && (t.x += canvas.width),
              t.x > canvas.width && (t.x -= canvas.width);
          });
        },
        draw() {
          (ctx.fillStyle = "#fff"),
            this.stars.forEach((e) => {
              ctx.fillStyle = e.color;
              ctx.beginPath(),
                ctx.arc(e.x, e.y, e.size / 2, 0, 2 * Math.PI),
                ctx.fill();
            });
        },
      };
      let gameState = "splash";
      const GRAVITY = 0.23;
      let gameTime = 0,
        score = 0,
        runSouls = 0,
        runTimer = 0,
        keys = {},
        mouse = { x: 0, y: 0, down: !1 },
        autoFire = !1,
        player,
        enemies = [],
        pProjs = [],
        eProjs = [],
        particles = [],
        orbs = [],
        wisp = null,
        dNums = [],
        runEnemiesKilled = 0,
        infiniteModeActive = false,
        lightningBolts = [],
        platforms = [],
        soulPopupTimer = null,
        leaderboardReturnScreen = null,
        optionsReturnScreen = null;
      let totalEnemiesThisWave = 0;
      let undergoingBossDefeatTransition = false;
      let currentGroundColor = "#1a1a2a";
      let currentGroundStrokeColor = "#9b59b6";
      let currentStarfieldConfig = 0;
      const orbiterStartWave = 4;
      const erraticStartWave = 4;
      const dashingStartWave = 4;
      const grounderStartWave = 4;
      const starfieldConfigs = [
        {
          near: 50,
          mid: 100,
          far: 200,
          baseSize: 1,
          colors: ["#FFFFFF", "#DDDDFF", "#BBBBFF"],
        },
        {
          near: 70,
          mid: 120,
          far: 250,
          baseSize: 1.2,
          colors: ["#FFDDDD", "#FFBBBB", "#FF9999"],
        },
        {
          near: 60,
          mid: 110,
          far: 220,
          baseSize: 0.9,
          colors: ["#DDFFDD", "#BBFFBB", "#99FF99"],
        },
        {
          near: 40,
          mid: 90,
          far: 180,
          baseSize: 1.1,
          colors: ["#FFFFDD", "#FFFFBB", "#FFFF99"],
        },
      ];
      let difficultySettings = {
        threatMultiplier: 1.0,
        enemyScalingMultiplier: 1.0,
      };
      let selectedDifficultyName = "Normal";
      let gameData = {
        totalSouls: 0,
        unlockedHats: ["hat_bruxo"],
        equippedHat: "hat_bruxo",
        soundEnabled: !0,
        aimLineEnabled: !0,
        showHitboxes: !1,
        showEnemyHealthBars: !0,
        showDamageNumbers: !0,
        parallaxEnabled: !0,
        showInventory: !0,
      };
      const HATS = {
        hat_bruxo: {
          name: "Chapéu de Bruxo",
          cost: 25,
          draw: (e) => {
            const t = spriteImages["hat_bruxo.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -50,
                50,
                50
              );
          },
        },
        hat_guerreiro: {
          name: "Elmo de Guerreiro",
          cost: 50,
          draw: (e) => {
            const t = spriteImages["hat_guerreiro.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -45,
                50,
                50
              );
          },
        },
        hat_ladino: {
          name: "Capuz de Ladino",
          cost: 100,
          draw: (e) => {
            const t = spriteImages["hat_ladino.png"];
            t &&
              t.complete &&
              e.drawImage(
                t,
                t.width * 0.1,
                t.height * 0.1,
                t.width * 0.8,
                t.height * 0.8,
                -25,
                -48,
                50,
                50
              );
          },
        },
      };
      function loadGameData() {
        try {
          const e = localStorage.getItem("voidSurvivorData");
          e &&
            ((gameData = { ...gameData, ...JSON.parse(e) }),
            (gameData.soundEnabled = !1 !== gameData.soundEnabled),
            (gameData.aimLineEnabled = !1 !== gameData.aimLineEnabled),
            (gameData.showHitboxes = !!gameData.showHitboxes),
            (gameData.showEnemyHealthBars = !!gameData.showEnemyHealthBars),
            (gameData.showDamageNumbers = !!gameData.showDamageNumbers),
            (gameData.parallaxEnabled = !1 !== gameData.parallaxEnabled));
        } catch (e) {
          console.error(e);
        }
      }
      function saveGameData() {
        try {
          localStorage.setItem("voidSurvivorData", JSON.stringify(gameData));
        } catch (e) {
          console.error(e);
        }
      }
      const HAT_SHOP = {
          init(e, t) {
            d.getElementById(t).innerText = gameData.totalSouls;
            const o = d.getElementById(e);
            o.innerHTML = "";
            for (const i in HATS) {
              const s = HATS[i],
                n = d.createElement("div");
              n.className = "hat-card";
              const a = d.createElement("canvas");
              (a.width = 60),
                (a.height = 60),
                this.drawHatPreview(a.getContext("2d"), s);
              const l = d.createElement("button");
              let r;
              gameData.unlockedHats.includes(i)
                ? gameData.equippedHat === i
                  ? ((l.innerText = "Equipado"),
                    (l.disabled = !0),
                    (l.className = "equipped"))
                  : ((l.innerText = "Equipar"), (r = () => this.equip(i, e, t)))
                : ((l.innerText = `Comprar (${s.cost})`),
                  gameData.totalSouls < s.cost
                    ? (l.disabled = !0)
                    : (r = () => this.buy(i, e, t))),
                r &&
                  (l.onclick = () => {
                    soundManager.playUIClickSound(), r();
                  }),
                (n.innerHTML = `<div>${s.name}</div>`),
                n.appendChild(a),
                n.appendChild(l),
                o.appendChild(n);
            }
          },
          drawHatPreview(e, t) {
            const o = e.canvas.width / 2,
              n = e.canvas.height - 5;
            e.save(), e.translate(o, n), t.draw(e), e.restore();
          },
          buy(e, t, o) {
            const i = HATS[e];
            gameData.totalSouls >= i.cost &&
              ((gameData.totalSouls -= i.cost),
              gameData.unlockedHats.push(e),
              saveGameData(),
              this.init(t, o),
              "gameOverHatShopContainer" === t &&
                HAT_SHOP.init("splashHatShopContainer", "splashSoulCount"));
          },
          equip(e, t, o) {
            (gameData.equippedHat = e),
              saveGameData(),
              this.init(t, o),
              "gameOverHatShopContainer" === t &&
                HAT_SHOP.init("splashHatShopContainer", "splashSoulCount");
          },
        },
        groundSegments = [];
      function generateGround() {
        groundSegments.length = 0;
        const segmentWidth = 40;
        let currentY = canvas.height - 50;
        const staircaseStartPoint = canvas.width * 0.8;
        const stepHeight = Math.random() * 35 - 15;

        for (
          let currentX = 0;
          currentX < canvas.width;
          currentX += segmentWidth
        ) {
          if (currentX < staircaseStartPoint) {
            groundSegments.push({
              x: currentX,
              y: currentY,
              width: segmentWidth,
            });
            if (Math.random() < 0.4) {
              currentY += Math.random() * 70 - 30;
              currentY = Math.max(
                canvas.height - 150,
                Math.min(canvas.height - 50, currentY)
              );
            }
          } else {
            currentY -= stepHeight;
            groundSegments.push({
              x: currentX,
              y: currentY,
              width: segmentWidth,
            });
          }
        }
      }
      function getGroundHeight(e) {
        return groundSegments.length
          ? groundSegments.find((t) => e >= t.x && e < t.x + t.width)?.y ||
              canvas.height
          : canvas.height;
      }
      const allUpgrades = [
        {
          name: "Essência do Vazio",
          description: "Aumenta o dano dos seus projéteis.",
          rarity: "common",
          icon: "catalisador.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentDmg = stats.projectileDamage;
            const increase = 2;
            const nextDmg = currentDmg + increase;
            return `Dano do Projétil: ${currentDmg} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextDmg}</span> (+${increase}).`;
          },
          apply: (e) => (e.stats.projectileDamage += 2),
        },
        {
          name: "Essência do Vazio +",
          description: "Aumenta ainda mais o dano dos seus projéteis.",
          rarity: "uncommon",
          icon: "catalisador2.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentDmg = stats.projectileDamage;
            const increase = 4;
            const nextDmg = currentDmg + increase;
            return `Dano do Projétil: ${currentDmg} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextDmg}</span> (+${increase}).`;
          },
          apply: (e) => (e.stats.projectileDamage += 4),
        },
        {
          name: "Vigor Primordial",
          description: "Aumenta seu HP Máximo.",
          rarity: "common",
          icon: "crescimento.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentHp = Math.floor(stats.maxHp);
            const increasePercent = 10;
            const nextHp = Math.floor(currentHp * 1.1);
            return `HP Máximo: ${currentHp} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextHp}</span> (+${increasePercent}%).`;
          },
          apply: (e) => {
            const hpIncrease = e.stats.maxHp * 0.1;
            e.stats.maxHp += hpIncrease;
            e.hp += hpIncrease;
            if (e.hp > e.stats.maxHp) e.hp = e.stats.maxHp;
          },
        },
        {
          name: "Vigor Primordial +",
          description: "Aumenta ainda mais seu HP Máximo.",
          rarity: "uncommon",
          icon: "crescimento2.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentHp = Math.floor(stats.maxHp);
            const increasePercent = 20;
            const nextHp = Math.floor(currentHp * 1.2);
            return `HP Máximo: ${currentHp} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextHp}</span> (+${increasePercent}%).`;
          },
          apply: (e) => {
            const hpIncrease = e.stats.maxHp * 0.2;
            e.stats.maxHp += hpIncrease;
            e.hp += hpIncrease;
            if (e.hp > e.stats.maxHp) e.hp = e.stats.maxHp;
          },
        },
        {
          name: "Vigor Primordial ++",
          description: "Aumenta drasticamente seu HP Máximo.",
          rarity: "rare",
          icon: "crescimento3.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentHp = Math.floor(stats.maxHp);
            const increasePercent = 40;
            const nextHp = Math.floor(currentHp * 1.4);
            return `HP Máximo: ${currentHp} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextHp}</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => {
            const hpIncrease = e.stats.maxHp * 0.4;
            e.stats.maxHp += hpIncrease;
            e.hp += hpIncrease;
            if (e.hp > e.stats.maxHp) e.hp = e.stats.maxHp;
          },
        },
        {
          name: "Raio Desintegrador",
          description:
            "Adiciona um raio laser contínuo que causa dano onde você mira, além dos seus ataques normais.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.laserBeam = true),
          isUnique: true,
        },
        {
          name: "Defletor Arcano",
          description:
            "Projéteis que interceptam disparos inimigos os destroem e absorvem seu poder, aumentando o próprio dano.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.interceptor = true),
          isUnique: true,
        },
        {
          name: "Salto Voltaico",
          description:
            "Ao atingir um inimigo, seu projétil salta para o inimigo mais próximo.",
          generatesNextLevelDescription: (currentPlayerStats, currentLevel) => {
            const currentJumps = currentPlayerStats.chainJumps || 0;
            const nextJumps = currentJumps + 1;
            return `Permite que o projétil salte para inimigos próximos. Saltos atuais: ${currentJumps} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextJumps}</span>.`;
          },
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.chainJumps = (e.stats.chainJumps || 0) + 1),
        },
        {
          name: "Eco Temporal",
          description: "Aumenta a Velocidade de Ataque.",
          rarity: "common",
          icon: "ressonancia.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentAS = stats.attackSpeed.toFixed(0);
            const multiplier = 0.88;
            const nextAS = (currentAS * multiplier).toFixed(0);
            const percentFaster = ((1 - multiplier) * 100).toFixed(0);
            return `Velocidade de Ataque: ${currentAS}ms <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextAS}ms</span> (<span style="color:lime;">+${percentFaster}%</span> mais rápido).`;
          },
          apply: (e) => (e.stats.attackSpeed *= 0.88),
        },
        {
          name: "Eco Temporal +",
          description: "Aumenta ainda mais a Velocidade de Ataque.",
          rarity: "uncommon",
          icon: "ressonancia2.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentAS = stats.attackSpeed.toFixed(0);
            const multiplier = 0.76;
            const nextAS = (currentAS * multiplier).toFixed(0);
            const percentFaster = ((1 - multiplier) * 100).toFixed(0);
            return `Velocidade de Ataque: ${currentAS}ms <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextAS}ms</span> (<span style="color:lime;">+${percentFaster}%</span> mais rápido).`;
          },
          apply: (e) => (e.stats.attackSpeed *= 0.76),
        },
        {
          name: "Passo Etéreo",
          description: "Aumenta a Velocidade de Movimento.",
          rarity: "common",
          icon: "velocidade.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentSpeedDisplay = (
              (stats.moveSpeed / (3.2 * 0.6)) *
              100
            ).toFixed(0);
            const increasePercent = 20;
            const nextSpeedDisplay = (
              ((stats.moveSpeed * 1.2) / (3.2 * 0.6)) *
              100
            ).toFixed(0);
            return `Vel. Movimento: Base +${
              parseFloat(currentSpeedDisplay) - 100
            }% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">Base +${
              parseFloat(nextSpeedDisplay) - 100
            }%</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => (e.stats.moveSpeed *= 1.2),
        },
        {
          name: "Passo Etéreo +",
          description: "Aumenta ainda mais a Velocidade de Movimento.",
          rarity: "uncommon",
          icon: "velocidade2.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentSpeedDisplay = (
              (stats.moveSpeed / (3.2 * 0.6)) *
              100
            ).toFixed(0);
            const increasePercent = 40;
            const nextSpeedDisplay = (
              ((stats.moveSpeed * 1.4) / (3.2 * 0.6)) *
              100
            ).toFixed(0);
            return `Vel. Movimento: Base +${
              parseFloat(currentSpeedDisplay) - 100
            }% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">Base +${
              parseFloat(nextSpeedDisplay) - 100
            }%</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => (e.stats.moveSpeed *= 1.4),
        },
        {
          name: "Estilhaços Entrópicos",
          description: "Ao morrer, inimigos liberam 2 projéteis fraco.",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const current = stats.fragmentation || 0;
            const next = current + 2;
            return `Inimigos liberam projéteis fracos ao morrer. Atual: ${current} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${next}</span>.`;
          },
          rarity: "uncommon",
          icon: "fragmentacao.png",
          apply: (e) =>
            (e.stats.fragmentation = (e.stats.fragmentation || 0) + 1),
        },
        {
          name: "Estilhaços Entrópicos +",
          description:
            "Ao morrer, inimigos liberam mais 4 projéteis fracos (total +3 desde base).",
          rarity: "rare",
          icon: "fragmentacao2.png",
          apply: (e) => (e.stats.fragmentation += 4),
        },
        {
          name: "Cometa Cinético",
          description:
            "A cada 1000px corridos, lança 1 projétil explosivo para cima",
          rarity: "uncommon",
          icon: "friccao.png",
          apply: (e) => (e.stats.frictionProjectiles += 1),
        },
        {
          name: "Cometa Cinético +",
          description:
            "A cada 1000px corridos, lança 3 projéteis explosivos para cima",
          rarity: "rare",
          icon: "friccao2.png",
          apply: (e) => (e.stats.frictionProjectiles += 3),
        },
        {
          name: "Sifão Vital",
          description: "Roubo de Vida: 3% do dano causado",
          rarity: "uncommon",
          icon: "sanguessuga.png",
          apply: (e) => (e.stats.lifeSteal += 0.03),
        },
        {
          name: "Sifão Vital +",
          description: "Roubo de Vida: 9% do dano causado",
          rarity: "rare",
          icon: "sanguessuga2.png",
          apply: (e) => (e.stats.lifeSteal += 0.09),
        },
        {
          name: "Fúria Celestial",
          description: "Chama relâmpagos do céu a cada 5s.",
          generatesNextLevelDescription: (currentPlayerStats, currentLevel) => {
            const currentBolts = currentPlayerStats.thunderboltCount || 0;
            const nextBolts = currentBolts + 2;
            return `Chama relâmpagos do céu a cada 5s. Relâmpagos atuais: ${currentBolts} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextBolts}</span>.`;
          },
          rarity: "uncommon",
          icon: "relampago.png",
          apply: (e) =>
            (e.stats.thunderboltCount = (e.stats.thunderboltCount || 0) + 2),
        },
        {
          name: "Fúria Celestial +",
          description: "Chama 3 relâmpagos do céu a cada 5s",
          rarity: "rare",
          icon: "relampago2.png",
          apply: (e) => (e.stats.thunderboltCount += 3),
        },
        {
          name: "Olho do Predador",
          description: "Aumenta a Chance de Acerto Crítico.",
          rarity: "common",
          icon: "common.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentCrit = (stats.critChance * 100).toFixed(0);
            const increase = 5;
            const nextCrit = Math.min(100, parseFloat(currentCrit) + increase);
            return `Chance de Crítico: ${currentCrit}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextCrit}%</span> (<span style="color:lime;">+${increase}%</span>).`;
          },
          apply: (e) =>
            (e.stats.critChance = Math.min(1.0, e.stats.critChance + 0.05)),
        },
        {
      name: "Salto Gravitacional",
      description: "Aumenta a Altura do seu Pulo.",
      rarity: "common",
      icon: "common.png",
      generatesNextLevelDescription: (stats, currentLevel) => {
        const baseJumpStrength = 15 * 0.6;
        const currentBonusPercent = (((stats.jumpStrength / baseJumpStrength) - 1) * 100).toFixed(0);
        const increasePercent = 6;
        
        const nextJumpStrength = stats.jumpStrength * 1.06;
        const nextBonusPercent = (((nextJumpStrength / baseJumpStrength) - 1) * 100).toFixed(0);

        return `Altura do Pulo: Atual (+${currentBonusPercent}%) <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">Próximo (+${nextBonusPercent}%)</span> (<span style="color:lime;">+${increasePercent}% do atual</span>).`;
      },
      apply: (e) => (e.stats.jumpStrength *= 1.06),
    },
        {
          name: "Pulso Restaurador",
          description: "Cura todo o HP.",
          rarity: "common",
          icon: "common.png",
          generatesNextLevelDescription: (
            stats,
            currentLevel,
            playerInstance
          ) => {
            const healAmount = Math.floor(stats.maxHp - playerInstance.hp);
            return `Restaura <span style="font-weight:bold; color:lime;">${Math.max(
              0,
              healAmount
            ).toFixed(0)}</span> de HP para o máximo.`;
          },
          apply: (e) => (e.hp = e.stats.maxHp),
          isUnique: true,
        },
        {
          name: "Carapaça de Ébano",
          description: "Aumenta sua Defesa.",
          rarity: "common",
          icon: "common.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentDef = stats.defense;
            const increase = 4;
            const nextDef = currentDef + increase;
            return `Defesa: ${currentDef} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextDef}</span> (+${increase}).`;
          },
          apply: (e) => (e.stats.defense += 4),
        },
        {
          name: "Ceifador de Almas",
          description:
            "Aumenta a chance de inimigos droparem orbes de alma (EXP permanente).",
          rarity: "common",
          icon: "common.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentChance = ((stats.soulOrbChance || 0) * 100).toFixed(0);
            const increase = 1;
            const nextChance = parseFloat(currentChance) + increase;
            return `Chance de Orbe de Alma: ${currentChance}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextChance}%</span> (<span style="color:lime;">+${increase}%</span>).`;
          },
          apply: (e) =>
            (e.stats.soulOrbChance = (e.stats.soulOrbChance || 0) + 0.01),
        },
        {
          name: "Lâmina Perfurante",
          description: "Aumenta a perfuração dos projéteis.",
          generatesNextLevelDescription: (currentPlayerStats, currentLevel) => {
            const currentPierce = currentPlayerStats.projectilePierce || 0;
            const nextPierce = currentPierce + 1;
            return `Projéteis perfuram inimigos. Perfurações atuais: ${currentPierce} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextPierce}</span>.`;
          },
          rarity: "common",
          icon: "common.png",
          apply: (e) => e.stats.projectilePierce++,
        },
        {
          name: "Disparo Hiper-sônico",
          description: "Aumenta a Velocidade dos Projéteis.",
          rarity: "common",
          icon: "common.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const baseProjSpeed = 8 * 0.6;
            const currentSpeedPercent = (
              (stats.projectileSpeed / baseProjSpeed - 1) *
              100
            ).toFixed(0);
            const increaseMult = 1.25;
            const nextSpeedPercent = (
              ((stats.projectileSpeed * increaseMult) / baseProjSpeed - 1) *
              100
            ).toFixed(0);
            return `Velocidade do Projétil: Atual (+${currentSpeedPercent}%) <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">Próximo (+${nextSpeedPercent}%)</span> (<span style="color:lime;">+25%</span>).`;
          },
          apply: (e) => (e.stats.projectileSpeed *= 1.25),
        },
        {
          name: "Singularidade Instável",
          description: "Aumenta o Tamanho dos Projéteis.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const baseSize = 5;
            const currentSizePercent = (
              ((stats.projectileSize || baseSize) / baseSize - 1) *
              100
            ).toFixed(0);
            const increasePercent = 20;
            const nextSizePercent = (
              (((stats.projectileSize || baseSize) * 1.2) / baseSize - 1) *
              100
            ).toFixed(0);
            return `Tamanho do Projétil: Atual (+${currentSizePercent}%) <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">Próximo (+${nextSizePercent}%)</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => (e.stats.projectileSize *= 1.2),
        },
        {
          name: "Manto Espectral",
          description:
            "Aumenta o tempo de invulnerabilidade após ser atingido.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentTime = stats.invulnerabilityTime.toFixed(0);
            const increasePercent = 10;
            const nextTime = (stats.invulnerabilityTime * 1.1).toFixed(0);
            return `Tempo Invul.: ${currentTime}ms <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextTime}ms</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => (e.stats.invulnerabilityTime *= 1.1),
        },
        {
          name: "Oráculo do Acaso",
          description: "Ganha cargas de Rerolar por subida de nível.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentCharges = stats.rerollCharges;
            const increase = 1;
            const nextCharges = currentCharges + increase;
            return `Cargas de Rerolar/Nível: ${currentCharges} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextCharges}</span> (<span style="color:lime;">+${increase}</span>).`;
          },
          apply: (e) => e.stats.rerollCharges++,
        },
        {
          name: "Pluma Ascendente",
          description: "Ganha pulos extras.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentExtraJumps = (stats.maxJumps || 1) - 1;
            const increase = 1;
            const nextExtraJumps = currentExtraJumps + increase;
            return `Pulos Extras: ${currentExtraJumps} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextExtraJumps}</span> (<span style="color:lime;">+${increase}</span>).`;
          },
          apply: (e) => e.stats.maxJumps++,
        },
        {
          name: "Dádiva do Destino",
          description: "Aumenta a chance de obter melhorias raras.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentLuck = ((stats.luck || 0) * 100).toFixed(0);
            const increase = 10;
            const nextLuck = parseFloat(currentLuck) + increase;
            return `Sorte (Raridade): ${currentLuck}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextLuck}%</span> (<span style="color:lime;">+${increase}%</span>).`;
          },
          apply: (e) => (e.stats.luck = (e.stats.luck || 0) + 0.1),
        },
        {
          name: "Bênção de Vida",
          description: "Inimigos têm chance de dropar orbes de cura.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentChance = ((stats.healOrbChance || 0) * 100).toFixed(0);
            const increase = 5;
            const nextChance = parseFloat(currentChance) + increase;
            return `Chance Orbe de Cura: ${currentChance}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextChance}%</span> (<span style="color:lime;">+${increase}%</span>).`;
          },
          apply: (e) =>
            (e.stats.healOrbChance = (e.stats.healOrbChance || 0) + 0.05),
        },
        {
          name: "Golpe Fatal",
          description: "Aumenta o dano de Acertos Críticos.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentCritDmgBonus = (
              (stats.critDamage - 1.5) *
              100
            ).toFixed(0);
            const increase = 50;
            const nextCritDmgBonus = parseFloat(currentCritDmgBonus) + increase;
            return `Dano Crítico Bônus: +${currentCritDmgBonus}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">+${nextCritDmgBonus}%</span> (<span style="color:lime;">+${increase}%</span>).`;
          },
          apply: (e) => (e.stats.critDamage += 0.5),
        },
        {
          name: "Coração Berserker",
          description:
            "Com menos de 50% de HP, ganha um bônus de dano (até +50%)",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.rage = !0),
        },
        {
          name: "Simbiose com a Horda",
          description: "Regenera HP com base no nº de inimigos vivos",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => (e.stats.hpRegenPerEnemy += 0.005),
        },
        {
          name: "Contração Dimensional",
          description: "Fica 10% menor",
          rarity: "uncommon",
          icon: "uncommon.png",
          apply: (e) => {
            (e.width *= 0.9), (e.height *= 0.9);
          },
        },
        {
          name: "Fome de Conhecimento",
          description: "Ganha mais EXP de todas as fontes.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentModifierPercent = (
              (stats.expGainModifier - 1) *
              100
            ).toFixed(0);
            const increasePercent = 20;
            const nextModifierPercent = (
              (stats.expGainModifier * 1.2 - 1) *
              100
            ).toFixed(0);
            return `Bônus de EXP: +${currentModifierPercent}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">+${nextModifierPercent}%</span> (<span style="color:lime;">+${increasePercent}%</span>).`;
          },
          apply: (e) => (e.stats.expGainModifier *= 1.2),
        },
        {
          name: "Feixe Colateral",
          description:
            "Seus acertos têm chance de disparar um feixe laser horizontal que atravessa inimigos.",
          rarity: "uncommon",
          icon: "uncommon.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentChance = (
              (stats.collateralBeamChance || 0) * 100
            ).toFixed(0);
            const chanceIncrease = 5;
            const nextChance = parseFloat(currentChance) + chanceIncrease;
            return `Chance de <span style="font-weight:bold; color:cyan;">${nextChance}%</span> de disparar um laser horizontal ao acertar.`;
          },
          apply: (e) => {
            if (
              !e.stats.collateralBeamChance ||
              e.stats.collateralBeamChance < 0.01
            ) {
              e.stats.collateralBeamChance = 0.2;
            } else {
              e.stats.collateralBeamChance = Math.min(
                0.5,
                e.stats.collateralBeamChance + 0.05
              );
              e.stats.collateralBeamDamageFactor = Math.min(
                0.75,
                (e.stats.collateralBeamDamageFactor || 0.25) + 0.05
              );
            }
          },
          generatesNextLevelDescription: (stats, currentLevel) => {
            const baseChance = 20;
            const incrementalChance = 5;
            const currentChanceVal = (stats.collateralBeamChance || 0) * 100;
            let nextChanceVal;
            if (currentLevel === 0) {
              nextChanceVal = baseChance;
            } else {
              nextChanceVal = Math.min(
                50,
                currentChanceVal + incrementalChance
              );
            }
            return `Acertos têm <span style="font-weight:bold; color:cyan;">${nextChanceVal}%</span> de chance de disparar um laser horizontal.`;
          },
        },
        {
          name: "Mente Expandida",
          description: "+1 escolha de melhoria por subida de nível",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => e.stats.upgradeChoices++,
        },
        {
          name: "Égide de Nulidade",
          description: "Cria um escudo que bloqueia 1 golpe a cada 15s",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.barrier = !0),
        },
        {
          name: "Toque Congelante",
          description: "Inimigos ficam 1% mais lentos por acerto (máx 80%)",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.cold = !0),
        },
        {
          name: "Meditação de Batalha",
          description:
            "Ganha velocidade de ataque a cada segundo que fica parado. Acumulável para maior bônus e teto mais alto.",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.focusLevel = (e.stats.focusLevel || 0) + 1),
        },
        {
          name: "Vontade Inquebrável",
          description: "+1 ressurreição (mata todos os inimigos ao reviver)",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => e.stats.revives++,
          isUnique: !0,
        },
        {
          name: "Aura Solar",
          description: "Seu corpo causa dano de contato aos inimigos.",
          rarity: "rare",
          icon: "rare.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentDmg = stats.contactDamage || 0;
            const increase = 40;
            const nextDmg = currentDmg + increase;
            return `Dano de Contato: ${currentDmg} <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextDmg}</span> (<span style="color:lime;">+${increase}</span>).`;
          },
          apply: (e) =>
            (e.stats.contactDamage = (e.stats.contactDamage || 0) + 40),
        },
        {
          name: "Tomo do Potencial",
          description:
            "Melhorias comuns (brancas) que você escolhe se tornam 35% mais eficazes",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.tome = !0),
        },
        {
          name: "Gêmeo Espectral",
          description:
            "Invoca um fogo-fátuo que herda metade do seu dano e velocidade de ataque",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => {
            wisp || ((wisp = new Wisp(e)), (e.stats.hasWisp = !0));
          },
        },
        {
          name: "Hemorragia Cósmica",
          description:
            "Causar dano aos inimigos faz com que eles sangrem com o tempo",
          rarity: "rare",
          icon: "rare.png",
          apply: (e) => (e.stats.wound = !0),
        },
        {
          name: "Precisão Mortal",
          description: "Aumenta drasticamente sua Chance de Acerto Crítico.",
          rarity: "rare",
          icon: "rare.png",
          generatesNextLevelDescription: (stats, currentLevel) => {
            const currentCrit = (stats.critChance * 100).toFixed(0);
            const increase = 15;
            const nextCrit = Math.min(100, parseFloat(currentCrit) + increase);
            return `Chance de Crítico +<span style="font-weight:bold; color:yellow;">${increase}%</span>. Atual: ${currentCrit}% <span style="color:#aaa;">-></span> <span style="font-weight:bold; color:lime;">${nextCrit}%</span>.`;
          },
          apply: (e) => {
            e.stats.critChance = Math.min(1.0, e.stats.critChance + 0.15);
          },
        },
      ];
      let availableUpgrades = [...allUpgrades];
      class Player {
        constructor() {
          (this.width = 50),
            (this.height = 90),
            (this.x = canvas.width / 2),
            (this.y = canvas.height - 200),
            (this.vx = 0),
            (this.vy = 0),
            (this.onGround = !1),
            (this.jumpsLeft = 0),
            (this.hp = 100),
            (this.exp = 0),
            (this.level = 1),
            (this.expToNextLevel = 100),
            (this.invulnerableTimer = 0),
            (this.shootCooldown = 0),
            (this.distanceTraveled = 0),
            (this.stillTimer = 0),
            (this.laserDamageTick = 0),
            (this.upgrades = new Map()),
            (this.stats = this.getBaseStats());
          this.isLevelingUp = false;
          this.rerollsLeft = this.stats.rerollCharges;
        }
        getBaseStats() {
          return {
            maxHp: 100,
            moveSpeed: 3.2 * 0.55,
            jumpStrength: 15 * 0.6,
            maxJumps: 1,
            attackSpeed: 700,
            projectileDamage: 10,
            projectileSpeed: 8 * 0.6,
            projectileSize: 5,
            projectilePierce: 1,
            critChance: 0.03,
            critDamage: 1.25,
            defense: 0,
            invulnerabilityTime: 120,
            luck: 0,
            upgradeChoices: 4,
            rerollCharges: 1,
            lifeSteal: 0,
            expGainModifier: 1.0,
            rage: !1,
            hpRegenPerEnemy: 0,
            healOrbChance: 0,
            soulOrbChance: 0,
            contactDamage: 0,
            fragmentation: 0,
            frictionProjectiles: 0,
            kineticCometQueue: [],
            kineticCometLaunchDelay: 100,
            kineticCometTimer: 0,
            thunderboltCount: 0,
            barrier: !1,
            barrierReady: !0,
            barrierCooldown: 15e3,
            barrierTimer: 0,
            cold: !1,
            focusLevel: 0,
            revives: 0,
            tome: !1,
            hasWisp: !1,
            wound: !1,
            laserBeam: false,
            interceptor: false,
            chainJumps: 0,
            collateralBeamChance: 0,
            collateralBeamDamageFactor: 0.25,
          };
        }
        getWeaponTip() {
          const e = this.x + this.width / 2,
            t = this.y + this.height / 2 - 20,
            i = e + 15,
            s = t - 10,
            n = Math.atan2(mouse.y - s, mouse.x - i),
            a = 60,
            l = i + Math.cos(n) * a,
            r = s + Math.sin(n) * a;
          return { x: l, y: r, angle: n };
        }
        update(e) {
          let t = !1;
          keys.a || keys.A
            ? ((this.vx = -this.stats.moveSpeed), (t = !0))
            : keys.d || keys.D
            ? ((this.vx = this.stats.moveSpeed), (t = !0))
            : (this.vx = 0),
            t
              ? ((this.distanceTraveled += Math.abs(this.vx)),
                (this.stillTimer = 0))
              : (this.stillTimer += e),
            (this.vy += GRAVITY),
            !this.onGround && (keys.s || keys.S) && (this.vy += 0.6),
            (this.y += this.vy);

          let onSurface = false;
          if (this.vy >= 0) {
            for (const p of platforms) {
              if (
                this.x < p.x + p.width &&
                this.x + this.width > p.x &&
                this.y + this.height >= p.y &&
                this.y + this.height - this.vy <= p.y + 1
              ) {
                this.y = p.y - this.height;
                this.vy = 0;
                onSurface = true;
                break;
              }
            }
            if (!onSurface) {
              const groundY = getGroundHeight(this.x + this.width / 2);
              if (this.y + this.height >= groundY) {
                this.y = groundY - this.height;
                this.vy = 0;
                onSurface = true;
              }
            }
          }
          if (onSurface) {
            if (!this.onGround) {
              this.jumpsLeft = this.stats.maxJumps;
            }
            this.onGround = true;
          } else {
            this.onGround = false;
          }

          (this.x += this.vx),
            this.x < 0 && (this.x = 0),
            this.x + this.width > canvas.width &&
              (this.x = canvas.width - this.width),
            this.invulnerableTimer > 0 && (this.invulnerableTimer -= e);
          this.laserDamageTick > 0 && (this.laserDamageTick -= e);
          this.shootCooldown > 0 && (this.shootCooldown -= e);

          if (
            this.stats.laserBeam &&
            (mouse.down || autoFire) &&
            this.laserDamageTick <= 0
          ) {
            this.laserDamageTick = 500;
            const { x: startX, y: startY } = this.getWeaponTip();
            const angle = Math.atan2(mouse.y - startY, mouse.x - startX);

            enemies.forEach((enemy) => {
              if (
                enemy.hp > 0 &&
                isEnemyIntersectedByRay(enemy, startX, startY, angle)
              ) {
                enemy.takeDamage(
                  this.stats.projectileDamage / 3,
                  Math.random() < this.stats.critChance
                );
              }
            });
          }

          if ((mouse.down || autoFire) && this.shootCooldown <= 0) {
            this.shoot();

            let finalAttackSpeed = this.stats.attackSpeed;
            if (this.stats.focusLevel > 0) {
              const rampUpBaseDuration = 8000;
              const rampUpDurationReductionPerLevel = 1000;
              const minRampUpDuration = 2500;

              let currentRampUpDuration =
                rampUpBaseDuration -
                rampUpDurationReductionPerLevel * (this.stats.focusLevel - 1);
              currentRampUpDuration = Math.max(
                minRampUpDuration,
                currentRampUpDuration
              );

              const focusBonusDivisor =
                1 + this.stillTimer / currentRampUpDuration;
              let focusModifiedAttackSpeed =
                this.stats.attackSpeed / focusBonusDivisor;

              const maxFocusLevelForCapCalc = 5;
              const effectiveFocusLevelForCap = Math.min(
                this.stats.focusLevel,
                maxFocusLevelForCapCalc
              );

              const baseCapPercentage = 0.5;
              const capPercentageReductionPerLevel = 0.07;
              const absoluteMinAttackSpeedMs = 40;

              let currentCapPercentage =
                baseCapPercentage -
                capPercentageReductionPerLevel *
                  (effectiveFocusLevelForCap - 1);
              currentCapPercentage = Math.max(0.1, currentCapPercentage);

              const minAttackSpeedFromPercentage =
                this.stats.attackSpeed * currentCapPercentage;
              const minAttackSpeedCap = Math.max(
                absoluteMinAttackSpeedMs,
                minAttackSpeedFromPercentage
              );

              focusModifiedAttackSpeed = Math.max(
                minAttackSpeedCap,
                focusModifiedAttackSpeed
              );
              finalAttackSpeed = focusModifiedAttackSpeed;
            }
            this.shootCooldown = finalAttackSpeed;
          }
          this.updateSpecial(e);
        }
        updateSpecial(e) {
          if (
            this.stats.frictionProjectiles > 0 &&
            this.distanceTraveled >= 1e3
          ) {
            for (let t = 0; t < this.stats.frictionProjectiles; t++)
              pProjs.push(
                new PlayerProjectile(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  -Math.PI / 2,
                  40,
                  true
                )
              );
            this.distanceTraveled = 0;
          }
          this.stats.barrier &&
            !this.stats.barrierReady &&
            ((this.stats.barrierTimer += e),
            this.stats.barrierTimer >= this.stats.barrierCooldown &&
              ((this.stats.barrierReady = !0), (this.stats.barrierTimer = 0))),
            this.stats.hpRegenPerEnemy > 0 &&
              this.heal(
                (enemies.length * this.stats.hpRegenPerEnemy * e) / 1e3
              );

          if (
            this.stats.frictionProjectiles > 0 &&
            this.distanceTraveled >= 1000
          ) {
            for (let i = 0; i < this.stats.frictionProjectiles; i++) {
              this.stats.kineticCometQueue.push({
                x: this.x + this.width / 2,
                y: this.y + this.height / 2,
                angle: -Math.PI / 2,
                damage: 40,
                isExplosive: true,
              });
            }
            this.distanceTraveled = 0;
            if (
              this.stats.kineticCometQueue.length > 0 &&
              this.stats.kineticCometTimer <= 0
            ) {
              this.stats.kineticCometTimer = this.stats.kineticCometLaunchDelay;
            }
          }

          if (
            this.stats.kineticCometQueue.length > 0 &&
            this.stats.kineticCometTimer > 0
          ) {
            this.stats.kineticCometTimer -= e;
            if (this.stats.kineticCometTimer <= 0) {
              const projData = this.stats.kineticCometQueue.shift();
              if (projData) {
                pProjs.push(
                  new PlayerProjectile(
                    projData.x,
                    projData.y,
                    projData.angle,
                    projData.damage,
                    projData.isExplosive
                  )
                );
                soundManager.playSound(300, 800, 0.1, "triangle", 0.3);
              }
              if (this.stats.kineticCometQueue.length > 0) {
                this.stats.kineticCometTimer =
                  this.stats.kineticCometLaunchDelay;
              }
            }
          } else if (
            this.stats.kineticCometQueue.length > 0 &&
            this.stats.kineticCometTimer <= 0
          ) {
            this.stats.kineticCometTimer = this.stats.kineticCometLaunchDelay;
          }
        }
        draw() {
          const e = this.x + this.width / 2,
            t = this.y + this.height / 2;
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "yellow"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          if (
            !(
              this.invulnerableTimer > 0 &&
              Math.floor(Date.now() / 100) % 2 == 0
            )
          ) {
            ctx.save(), ctx.translate(e, t);
            const a = spriteImages["corpo.png"];
            a && a.complete
              ? ctx.drawImage(a, -30, -30, 60, 80)
              : ((ctx.strokeStyle = "#fff"),
                (ctx.lineWidth = 2),
                ctx.beginPath(),
                ctx.moveTo(0, -this.height / 2),
                ctx.lineTo(this.width / 2, this.height / 2),
                ctx.lineTo(-this.width / 2, this.height / 2),
                ctx.closePath(),
                ctx.stroke());
            ctx.save(),
              ctx.translate(0, -this.height / 2 + 30),
              gameData.equippedHat &&
                HATS[gameData.equippedHat] &&
                HATS[gameData.equippedHat].draw(ctx),
              ctx.restore();
            const s = Math.atan2(mouse.y - t, mouse.x - e),
              i = spriteImages["wpn_staff.png"];
            if (i && i.complete) {
              ctx.save(),
                ctx.translate(15, -10),
                ctx.rotate(s + 1.4708),
                ctx.drawImage(i, -10, -55, 20, 70),
                ctx.restore();
            } else {
              const r = 0.8 * this.height,
                h = Math.cos(s) * r,
                c = Math.sin(s) * r;
              (ctx.strokeStyle = "#00ffff"),
                (ctx.lineWidth = 4),
                ctx.beginPath(),
                ctx.moveTo(0, 0),
                ctx.lineTo(h, c),
                ctx.stroke(),
                (ctx.fillStyle = "#00ffff"),
                ctx.beginPath(),
                ctx.arc(h, c, 5, 0, 2 * Math.PI),
                ctx.fill();
            }
            this.stats.barrier &&
              this.stats.barrierReady &&
              ((ctx.strokeStyle = "rgba(100,200,255,.8)"),
              (ctx.lineWidth = 3),
              ctx.beginPath(),
              ctx.arc(0, 0, 5 + this.height / 2, 0, 2 * Math.PI),
              ctx.stroke());
            const p = 60,
              l = 8,
              d = this.hp / this.stats.maxHp,
              y = -this.height / 2 - 20;
            (ctx.fillStyle = "rgba(0,0,0,0.5)"),
              ctx.fillRect(-p / 2, y, p, l),
              (ctx.fillStyle = "#c0392b"),
              ctx.fillRect(-p / 2, y, p * d, l),
              (ctx.strokeStyle = "rgba(255,255,255,0.7)"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(-p / 2, y, p, l);
            const txt = `${Math.ceil(this.hp)}/${Math.ceil(this.stats.maxHp)}`;
            (ctx.font = "10px 'Press Start 2P'"),
              (ctx.textAlign = "center"),
              (ctx.textBaseline = "middle"),
              (ctx.fillStyle = "#000"),
              ctx.fillText(txt, 0, y + l / 2 + 1),
              (ctx.fillStyle = "#fff"),
              ctx.fillText(txt, 0, y + l / 2),
              ctx.restore();
          }
          if (gameData.aimLineEnabled) {
            const { x: n, y: u } = this.getWeaponTip();
            let g = !1;
            for (const m of enemies)
              if (
                mouse.x > m.x &&
                mouse.x < m.x + m.width &&
                mouse.y > m.y &&
                mouse.y < m.y + m.height
              ) {
                g = !0;
                break;
              }
            ctx.beginPath(),
              ctx.moveTo(n, u),
              ctx.lineTo(mouse.x, mouse.y),
              (ctx.strokeStyle = g
                ? "rgba(255,100,100,0.25)"
                : "rgba(255,255,255,0.1)"),
              (ctx.lineWidth = 1),
              ctx.stroke();
          }
          if (this.stats.laserBeam && (mouse.down || autoFire)) {
            const { x: startX, y: startY } = this.getWeaponTip();
            const angle = Math.atan2(mouse.y - startY, mouse.x - startX);
            const laserLength = Math.max(canvas.width, canvas.height) * 2;
            const endX = startX + Math.cos(angle) * laserLength;
            const endY = startY + Math.sin(angle) * laserLength;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = "#ff4747";
            ctx.lineWidth = 3 + Math.random() * 2;
            ctx.shadowColor = "#ff0000";
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.restore();
          }
        }
        jump() {
          if (this.jumpsLeft > 0) {
            soundManager.playJumpSound();
            this.vy = -this.stats.jumpStrength;
            this.jumpsLeft--;
            this.onGround = false;
          }
        }
        shoot() {
          soundManager.playShootSound();
          const { x: e, y: t, angle: o } = this.getWeaponTip();
          pProjs.push(new PlayerProjectile(e, t, o));
        }
        takeDamage(e) {
          if (this.invulnerableTimer > 0) return;
          if (this.stats.barrier && this.stats.barrierReady)
            return (
              (this.stats.barrierReady = !1),
              void (this.invulnerableTimer = 500)
            );
          soundManager.playPlayerDamageSound();
          const t = Math.max(1, e - this.stats.defense);
          if (
            ((this.hp -= t),
            (this.invulnerableTimer = this.stats.invulnerabilityTime),
            this.hp <= 0)
          )
            if (this.stats.revives > 0)
              this.stats.revives--,
                (this.hp = this.stats.maxHp),
                enemies.forEach((e) => (e.hp = 0)),
                (availableUpgrades = availableUpgrades.filter(
                  (e) => "Vontade Inquebrável" !== e.name
                ));
            else {
              soundManager.playGameOverSound(),
                (gameState = "gameOver"),
                saveGameData(),
                (gameOverScreen.style.display = "flex");

              d.getElementById("gameOverStats").innerHTML = `
                <strong>Pontuação Final:</strong> ${score}<br>
                <strong>Onda Concluída:</strong> ${currentWave}<br>
                <strong>Inimigos Derrotados:</strong> ${runEnemiesKilled}<br>
                <strong>Tempo:</strong> ${formatTime(runTimer)}<br>`;

              Leaderboard.show();
            }
        }
        heal(e) {
          this.hp = Math.min(this.stats.maxHp, this.hp + e);
        }
        gainExp(e) {
          if (gameState !== "playing" || this.isLevelingUp) {
            if (this.isLevelingUp && gameState === "playing") {
              const expGained = e * this.stats.expGainModifier;
              this.exp += expGained;
              score += Math.round(e);
            }
            return;
          }

          const expGained = e * this.stats.expGainModifier;
          this.exp += expGained;
          score += Math.round(e);

          if (this.exp >= this.expToNextLevel && !this.isLevelingUp) {
            this.isLevelingUp = true;
            d.getElementById("exp-bar").style.backgroundColor = "#3498db";
            d.getElementById("exp-bar").style.width = "100%";
            const expText = d.getElementById("exp-bar-text");
            if (expText)
              expText.innerText = `${this.expToNextLevel}/${this.expToNextLevel} (100%)`;

            setTimeout(() => {
              if (gameState === "playing") {
                this.performLevelUpActions();
              } else {
                this.isLevelingUp = false;
                d.getElementById("exp-bar").style.backgroundColor = "#2ecc71";
              }
            }, 1000);
          } else if (!this.isLevelingUp) {
            const expPercent = Math.min(
              100,
              (this.exp / this.expToNextLevel) * 100
            );
            d.getElementById("exp-bar").style.width = `${expPercent}%`;
            d.getElementById("exp-bar-text").innerText = `${Math.floor(
              this.exp
            )}/${this.expToNextLevel} (${expPercent.toFixed(0)}%)`;
          }
        }

        performLevelUpActions() {
          if (gameState !== "playing") {
            this.isLevelingUp = false;
            d.getElementById("exp-bar").style.backgroundColor = "#2ecc71";
            return;
          }

          let levelsGainedThisCycle = 0;
          while (this.exp >= this.expToNextLevel && gameState === "playing") {
            this.level++;
            const excessExp = this.exp - this.expToNextLevel;
            this.exp = Math.max(0, excessExp);
            this.expToNextLevel = Math.floor(
              this.expToNextLevel * 1.15 + this.level * 5
            );
            levelsGainedThisCycle++;
          }

          if (levelsGainedThisCycle > 0) {
            this.hp = this.stats.maxHp;
            this.rerollsLeft = this.stats.rerollCharges;

            soundManager.playLevelUpSound();
            triggerLevelUp();

            d.getElementById("exp-bar").style.backgroundColor = "#2ecc71";
          }
          this.isLevelingUp = false;
        }

        levelUp() {
          if (gameState !== "playing") return;

          this.level++;
          const carryOverExp = this.exp - this.expToNextLevel;
          this.exp = Math.max(0, carryOverExp);

          this.expToNextLevel = Math.floor(
            this.expToNextLevel * 1.15 + this.level * 5
          );

          this.hp = this.stats.maxHp;
          this.rerollsLeft = this.stats.rerollCharges;

          soundManager.playLevelUpSound();
          triggerLevelUp();
        }
        gainRandomRareUpgrade() {
          const rareUpgrades = allUpgrades.filter(
            (u) =>
              u.rarity === "rare" && (!u.isUnique || !this.upgrades.has(u.name))
          );
          if (rareUpgrades.length > 0) {
            const chosenUpgrade =
              rareUpgrades[Math.floor(Math.random() * rareUpgrades.length)];

            chosenUpgrade.apply(this);
            if (chosenUpgrade.isUnique) {
              availableUpgrades = availableUpgrades.filter(
                (u) => u.name !== chosenUpgrade.name
              );
            }
            const currentCount = this.upgrades.get(chosenUpgrade.name) || 0;
            this.upgrades.set(chosenUpgrade.name, currentCount + 1);

            waveAnnouncer.innerText = `RECOMPENSA CHEFE: ${chosenUpgrade.name}`;
            waveAnnouncer.style.opacity = 1;
            setTimeout(() => {
              waveAnnouncer.style.opacity = 0;
            }, 3000);

            updateInventoryUI();
          } else {
            waveAnnouncer.innerText = `RECOMPENSA CHEFE: Nenhuma melhoria rara disponível!`;
            waveAnnouncer.style.opacity = 1;
            setTimeout(() => {
              waveAnnouncer.style.opacity = 0;
            }, 3000);
          }
        }
      }
      class DamageNumber {
        constructor(e, t, o, i) {
          (this.x = e),
            (this.y = t),
            (this.text = o),
            (this.isCrit = i),
            (this.life = 60),
            (this.vy = -1);
        }
        update() {
          (this.y += this.vy), (this.vy += 0.03), this.life--;
        }
        draw() {
          ctx.save(),
            (ctx.globalAlpha = Math.max(0, this.life / 60)),
            (ctx.fillStyle = this.isCrit ? "#f1c40f" : "#fff"),
            (ctx.font = this.isCrit
              ? "bold 18px Courier New"
              : "14px Courier New"),
            (ctx.textAlign = "center"),
            ctx.fillText(this.text, this.x, this.y),
            ctx.restore();
        }
      }
      let currentWave = 0,
        waveState = "intermission",
        intermissionTimer = 3e3;
      const WAVE_DEFS = [
        { wave: 1, enemies: { LacaioDoVazio: 3 } },
        { wave: 2, enemies: { LacaioDoVazio: 5 } },
        { wave: 3, enemies: { LacaioDoVazio: 7 } },
        { wave: 4, enemies: { LacaioDoVazio: 5, SentinelaEspectral: 1 } },
        { wave: 5, enemies: { LacaioDoVazio: 8, SentinelaEspectral: 2 } },
        { wave: 6, enemies: { GuardiaoAnomalo: 1, LacaioDoVazio: 4 } },
        { wave: 7, enemies: { GuardiaoAnomalo: 1, SentinelaEspectral: 2 } },
        { wave: 8, enemies: { LacaioDoVazio: 10, SentinelaEspectral: 3 } },
        { wave: 9, enemies: { GuardiaoAnomalo: 2, LacaioDoVazio: 5 } },
        {
          wave: 10,
          enemies: {
            GuardiaoAnomalo: 1,
            LacaioDoVazio: 8,
            SentinelaEspectral: 4,
          },
        },
      ];
      function updateWaveSystem(e) {
        if (gameState !== "playing") return;

        if ("intermission" === waveState) {
          if (
            currentWave >= 15 &&
            enemies.length === 0 &&
            !infiniteModeActive
          ) {
            showVictoryScreen();
            return;
          }

          intermissionTimer -= e;
          if (intermissionTimer <= 0) {
            currentWave++;
            spawnWave(currentWave);
            waveState = "fighting";
            const waveText =
              currentWave % 5 === 0 && currentWave > 0
                ? "CHEFE"
                : `ONDA ${currentWave}`;
            waveAnnouncer.innerText = waveText;
            waveAnnouncer.style.opacity = 1;
            setTimeout(() => {
              waveAnnouncer.style.opacity = 0;
            }, 2e3);
          }
        } else if ("fighting" === waveState && enemies.length === 0) {
          waveState = "intermission";
          intermissionTimer = 3e3;
        }
      }

      function spawnWave(e) {
        enemies.length = 0;
        totalEnemiesThisWave = 0;

        if (e % 5 === 0 && e > 0 && e <= 15) {
          const proceduralDefForBossHP = createProceduralWave(e);
          const bossHP = calculateWaveHP(proceduralDefForBossHP);
          enemies.push(new BossEnemy(bossHP, e));
        } else {
          let waveDef = createProceduralWave(e);
          for (const enemyName in waveDef.enemies) {
            for (let i = 0; i < waveDef.enemies[enemyName]; i++) {
              if (ENEMY_TYPES[enemyName]) {
                enemies.push(new ENEMY_TYPES[enemyName](e));
              }
            }
          }

          if (e % 3 === 0 && e > 0) {
            if (enemies.length > 0) {
              enemies.shift();
            }
            enemies.push(new EliteEnemy(e));
          }
        }
        totalEnemiesThisWave = enemies.length;
      }

      function createProceduralWave(e) {
        let baseThreat = 3 + Math.floor(e * 1.25);
        if (e > 10) baseThreat += Math.floor((e - 10) * 0.75);
        if (e > 20) baseThreat += Math.floor((e - 20) * 0.5);
        let threatPoints = baseThreat * difficultySettings.threatMultiplier;

        const enemyComposition = {
          LacaioDoVazio: 0,
          SentinelaEspectral: 0,
          GuardiaoAnomalo: 0,
          OrbiterEnemy: 0,
          ErraticLurker: 0,
          DashingPhantom: 0,
          GroundSkulker: 0,
        };

        const threatCosts = {
          LacaioDoVazio: 1,
          SentinelaEspectral: 2,
          GuardiaoAnomalo: 3.5,
          OrbiterEnemy: 1.5,
          ErraticLurker: 2.5,
          DashingPhantom: 2.5,
          GroundSkulker: 3,
        };

        let guaranteedSpecialSpawnedThisWave = false;

        if (e >= 4 && e % 2 === 0) {
          const specialTypesAvailableForGuarantee = [];
          if (e >= orbiterStartWave)
            specialTypesAvailableForGuarantee.push("OrbiterEnemy");
          if (e >= erraticStartWave)
            specialTypesAvailableForGuarantee.push("ErraticLurker");
          if (e >= dashingStartWave)
            specialTypesAvailableForGuarantee.push("DashingPhantom");
          if (e >= grounderStartWave)
            specialTypesAvailableForGuarantee.push("GroundSkulker");

          if (specialTypesAvailableForGuarantee.length > 0) {
            const chosenSpecial =
              specialTypesAvailableForGuarantee[
                Math.floor(
                  Math.random() * specialTypesAvailableForGuarantee.length
                )
              ];
            if (threatPoints >= threatCosts[chosenSpecial]) {
              enemyComposition[chosenSpecial]++;
              threatPoints -= threatCosts[chosenSpecial];
              guaranteedSpecialSpawnedThisWave = true;
            }
          }
        }

        let initialBudget = threatPoints * 0.6;

        while (initialBudget > 0) {
          let spawnedThisIteration = false;
          if (
            e > 3 &&
            initialBudget >= threatCosts.GuardiaoAnomalo &&
            Math.random() < 0.3
          ) {
            enemyComposition.GuardiaoAnomalo++;
            initialBudget -= threatCosts.GuardiaoAnomalo;
            spawnedThisIteration = true;
          } else if (
            e > 1 &&
            initialBudget >= threatCosts.SentinelaEspectral &&
            Math.random() < 0.4
          ) {
            enemyComposition.SentinelaEspectral++;
            initialBudget -= threatCosts.SentinelaEspectral;
            spawnedThisIteration = true;
          } else if (initialBudget >= threatCosts.LacaioDoVazio) {
            enemyComposition.LacaioDoVazio++;
            initialBudget -= threatCosts.LacaioDoVazio;
            spawnedThisIteration = true;
          }
          if (!spawnedThisIteration) break;
          threatPoints = initialBudget + threatPoints * 0.4;
        }

        let remainingBudgetForSpecials = threatPoints;
        const maxSpecialAttempts = 5;
        let specialAttempts = 0;

        while (
          remainingBudgetForSpecials > 0 &&
          specialAttempts < maxSpecialAttempts
        ) {
          specialAttempts++;
          let spawnedSpecialThisIteration = false;
          const specialCandidates = [];
          if (
            e >= orbiterStartWave &&
            remainingBudgetForSpecials >= threatCosts.OrbiterEnemy
          )
            specialCandidates.push({ name: "OrbiterEnemy", chance: 0.5 });
          if (
            e >= erraticStartWave &&
            remainingBudgetForSpecials >= threatCosts.ErraticLurker
          )
            specialCandidates.push({ name: "ErraticLurker", chance: 0.4 });
          if (
            e >= dashingStartWave &&
            remainingBudgetForSpecials >= threatCosts.DashingPhantom
          )
            specialCandidates.push({ name: "DashingPhantom", chance: 0.4 });
          if (
            e >= grounderStartWave &&
            remainingBudgetForSpecials >= threatCosts.GroundSkulker
          )
            specialCandidates.push({ name: "GroundSkulker", chance: 0.35 });

          if (specialCandidates.length === 0) break;

          specialCandidates.sort((a, b) => b.chance - a.chance);

          for (const candidate of specialCandidates) {
            if (Math.random() < candidate.chance) {
              enemyComposition[candidate.name]++;
              remainingBudgetForSpecials -= threatCosts[candidate.name];
              spawnedSpecialThisIteration = true;
              break;
            }
          }
          if (
            !spawnedSpecialThisIteration &&
            specialCandidates.length > 0 &&
            remainingBudgetForSpecials >= threatCosts.LacaioDoVazio
          ) {
            enemyComposition.LacaioDoVazio++;
            remainingBudgetForSpecials -= threatCosts.LacaioDoVazio;
          } else if (!spawnedSpecialThisIteration) {
            break;
          }
          threatPoints = remainingBudgetForSpecials;
        }

        while (threatPoints >= threatCosts.LacaioDoVazio) {
          enemyComposition.LacaioDoVazio++;
          threatPoints -= threatCosts.LacaioDoVazio;
        }

        let totalSpawned = Object.values(enemyComposition).reduce(
          (sum, count) => sum + count,
          0
        );
        if (e % 5 !== 0 && totalSpawned === 0 && e > 0) {
          enemyComposition.LacaioDoVazio = 1 + Math.floor(e / 3);
        }

        return { wave: e, enemies: enemyComposition };
      }
      class Enemy {
        constructor(wave = 1) {
          this.x = Math.random() * (canvas.width - 50) + 25;
          this.y = -50;
          this.chaseHeight = canvas.height * (0.15 + 0.2 * Math.random());
          this.state = "descending";
          this.shootTimer = 1000 * Math.random();
          this.slowFactor = 1;
          this.bleedTimer = 0;
          this.bleedDamage = 0;
          this.hitFlashTimer = 0;
          this.wave = wave;
          this.scaleFactor =
            (1 + (this.wave - 1) * 0.1) *
            difficultySettings.enemyScalingMultiplier;
          this.currentMoveAngle = Math.random() * Math.PI * 2;
          this.turnCooldown = 0;
          this.timeToTurn = 600 + Math.random() * 400;
        }

        update(e) {
          let isGroundSkulkerType = this.constructor.name === "GroundSkulker";

          if (!isGroundSkulkerType) {
            const groundY = getGroundHeight(this.x + this.width / 2);
            const avoidGroundBuffer = this.height * 0.25;
            if (this.y + this.height > groundY - avoidGroundBuffer) {
              this.y = groundY - avoidGroundBuffer - this.height;
              if (
                this.currentMoveAngle &&
                Math.sin(this.currentMoveAngle) > 0
              ) {
                this.currentMoveAngle *= -1;
                this.currentMoveAngle =
                  ((this.currentMoveAngle % (2 * Math.PI)) + 2 * Math.PI) %
                  (2 * Math.PI);
              } else if (
                typeof this.vy !== "undefined" &&
                this.vy > 0 &&
                !this.currentMoveAngle
              ) {
                this.vy *= -0.5;
              }
            }
          }

          if ("descending" === this.state) {
            this.y += this.speed * 0.7;
            if (this.y > this.chaseHeight) {
              this.state = "chasing";
              if (typeof this.currentMoveAngle !== "undefined") {
                this.currentMoveAngle = Math.atan2(
                  player.y - this.y,
                  player.x - this.x
                );
              }
            }
          } else if ("chasing" === this.state) {
            let separationX = 0;
            let separationY = 0;
            const SEPARATION_BUFFER = 5;

            enemies.forEach((otherEnemy) => {
              if (otherEnemy === this || otherEnemy.hp <= 0) return;
              const dx = this.x - otherEnemy.x;
              const dy = this.y - otherEnemy.y;
              const distance = Math.hypot(dx, dy);
              const thisRadius = (this.width + this.height) / 4;
              const otherRadius = (otherEnemy.width + otherEnemy.height) / 4;
              const combinedRadius =
                thisRadius + otherRadius + SEPARATION_BUFFER;

              if (distance < combinedRadius && distance > 0) {
                const overlap = combinedRadius - distance;
                const pushX = dx / distance;
                const pushY = dy / distance;
                separationX += pushX * (overlap / combinedRadius) * 1.5;
                separationY += pushY * (overlap / combinedRadius) * 1.5;
              }
            });

            const sepMagnitude = Math.hypot(separationX, separationY);
            if (sepMagnitude > 1.0) {
              separationX /= sepMagnitude;
              separationY /= sepMagnitude;
            }

            const isDefaultBehavior =
              this.constructor.name === "LacaioDoVazio" ||
              this.constructor.name === "GuardiaoAnomalo" ||
              this.constructor.name === "SentinelaEspectral" ||
              (this instanceof EliteEnemy &&
                this.constructor.name === "EliteEnemy") ||
              (this instanceof BossEnemy &&
                this.constructor.name === "BossEnemy");

            if (
              isDefaultBehavior &&
              this.constructor.name !== "OrbiterEnemy" &&
              this.constructor.name !== "ErraticLurker" &&
              this.constructor.name !== "DashingPhantom" &&
              this.constructor.name !== "GroundSkulker"
            ) {
              const targetPlayerYPos =
                this.chaseHeight +
                20 * Math.sin(gameTime / 1000 + this.x / 150);
              let targetPlayerXPos = player.x + player.width / 2;

              if (
                this.aiType === "sniper" &&
                Math.abs(targetPlayerXPos - (this.x + this.width / 2)) < 400
              ) {
                targetPlayerXPos =
                  this.x +
                  this.width / 2 -
                  250 * Math.sign(targetPlayerXPos - (this.x + this.width / 2));
              } else if (
                this.aiType !== "sniper" &&
                Math.abs(targetPlayerXPos - (this.x + this.width / 2)) < 150
              ) {
                targetPlayerXPos =
                  this.x +
                  this.width / 2 -
                  100 * Math.sign(targetPlayerXPos - (this.x + this.width / 2));
              }

              const angleToDirectTarget = Math.atan2(
                targetPlayerYPos - (this.y + this.height / 2),
                targetPlayerXPos - (this.x + this.width / 2)
              );

              let finalMoveX =
                Math.cos(angleToDirectTarget) * this.speed * this.slowFactor;
              let finalMoveY =
                Math.sin(angleToDirectTarget) * this.speed * this.slowFactor;

              this.x += finalMoveX + separationX * this.speed * 0.6;
              this.y += finalMoveY + separationY * this.speed * 0.6;
            }

            (this.shootTimer += e),
              this.shootTimer >= this.shootCooldown &&
                (this.shoot(), (this.shootTimer = 0));
          }

          const MIN_Y_DEFAULT = 50;
          const MIN_Y_SPECIAL_TYPES = 20;

          let isSpecialMinYType =
            this.constructor.name === "ErraticLurker" ||
            this.constructor.name === "GroundSkulker" ||
            this.constructor.name === "OrbiterEnemy";
          let actualMinY = isSpecialMinYType
            ? MIN_Y_SPECIAL_TYPES
            : MIN_Y_DEFAULT;

          let bouncedOnBoundary = false;
          if (this.x < 0) {
            this.x = 0;
            if (typeof this.currentMoveAngle !== "undefined")
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
            else if (typeof this.vx !== "undefined") this.vx *= -0.5;
            bouncedOnBoundary = true;
          } else if (this.x + this.width > canvas.width) {
            this.x = canvas.width - this.width;
            if (typeof this.currentMoveAngle !== "undefined")
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
            else if (typeof this.vx !== "undefined") this.vx *= -0.5;
            bouncedOnBoundary = true;
          }

          if (this.y < actualMinY) {
            this.y = actualMinY;
            if (
              typeof this.currentMoveAngle !== "undefined" &&
              Math.sin(this.currentMoveAngle) < 0
            ) {
              this.currentMoveAngle *= -1;
            } else if (typeof this.vy !== "undefined" && this.vy < 0) {
              this.vy *= -0.5;
            }
            bouncedOnBoundary = true;
          }

          if (
            bouncedOnBoundary &&
            typeof this.currentMoveAngle !== "undefined"
          ) {
            this.currentMoveAngle =
              ((this.currentMoveAngle % (2 * Math.PI)) + 2 * Math.PI) %
              (2 * Math.PI);
            if (
              typeof this.turnCooldown !== "undefined" &&
              typeof this.timeToTurn !== "undefined"
            ) {
              this.turnCooldown = this.timeToTurn * 0.5;
            }
          }

          if (this.bleedDamage > 0 && this.hp > 0) {
            this.bleedTimer += e;
            if (this.bleedTimer >= 1e3) {
              const damageFromBleed = this.bleedDamage;
              this.takeDamage(damageFromBleed, false, true);
              if (damageFromBleed > 0) {
                this.hitFlashTimer = 100;
              }
              this.bleedTimer = 0;
              if (this.hp <= 0) {
                this.die();
              }
            }
          }

          if (this.hp > 0 && checkCollision(this, player)) {
            player.takeDamage(this.damage);
            if (player.stats.contactDamage > 0) {
              this.takeDamage(player.stats.contactDamage, false, false);
            }
          }
          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
        }
        drawHealthBar() {
          if (!gameData.showEnemyHealthBars) return;
          (ctx.fillStyle = "#333"),
            ctx.fillRect(this.x, this.y - 10, this.width, 5),
            (ctx.fillStyle = "#e74c3c"),
            ctx.fillRect(
              this.x,
              this.y - 10,
              this.width * (this.hp / this.maxHp),
              5
            ),
            (ctx.fillStyle = "#fff"),
            (ctx.font = '10px "Courier New"'),
            (ctx.textAlign = "center"),
            ctx.fillText(
              `${Math.ceil(this.hp)}/${this.maxHp}`,
              this.x + this.width / 2,
              this.y - 14
            ),
            (ctx.textAlign = "left");
        }
        drawHitFlash() {
          if (this.hitFlashTimer > 0) {
            const flashIntensity = 0.6 + Math.sin(gameTime * 0.05) * 0.2;
            ctx.save();
            ctx.globalAlpha = flashIntensity;

            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fillRect(this.x, this.y, this.width, this.height);

            if (this.auraColor && typeof this.drawAura === "function") {
              this.drawAura(true, flashIntensity * 1.5);
            }
            ctx.restore();
          }
        }
        takeDamage(e, t = !1, o = !1) {
          if (this.hp <= 0) return;

          if (!o) {
            soundManager.playEnemyHitSound();
            this.hitFlashTimer = 100;
          }

          gameData.showDamageNumbers &&
            dNums.push(
              new DamageNumber(
                this.x + this.width / 2,
                this.y,
                Math.round(e),
                t
              )
            );

          this.hp -= e;

          if (this.hp <= 0 && !o) {
            this.die();
          }
        }
        die() {
          if (this.hp > 0 && enemies.includes(this)) {
          }
          this.hp = 0;
          this.hp = 0;
          runEnemiesKilled++;
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;
          const baseParticleCount = 25 + Math.floor(this.width / 3);
          const explosionColor = this.auraColor
            ? this.auraColor.replace(/,\s*\d?\.?\d+\)/, ", 0.8)")
            : "rgba(220, 220, 240, 0.8)";

          createExplosion(
            centerX,
            centerY,
            explosionColor,
            baseParticleCount,
            5,
            60,
            0.8,
            0.4
          );
          createExplosion(
            centerX,
            centerY,
            "rgba(255, 255, 255, 0.9)",
            Math.floor(baseParticleCount / 3),
            8,
            30,
            0.5,
            0.3
          );
          soundManager.playEnemyDieSound(),
            player.gainExp(this.expValue),
            Math.random() < 0.8 &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "soul_currency"
                )
              ),
            player.stats.fragmentation > 0 &&
              Array.from({ length: player.stats.fragmentation }).forEach(() => {
                let t = null;
                const otherEnemies = enemies.filter(
                  (enemy) => enemy !== this && enemy.hp > 0
                );
                if (otherEnemies.length > 0) {
                  t =
                    otherEnemies[
                      Math.floor(Math.random() * otherEnemies.length)
                    ];
                }
                const o = t
                  ? Math.atan2(
                      t.y + t.height / 2 - (this.y + this.height / 2),
                      t.x + t.width / 2 - (this.x + this.width / 2)
                    )
                  : 2 * Math.random() * Math.PI;
                pProjs.push(
                  new PlayerProjectile(
                    this.x + this.width / 2,
                    this.y + this.height / 2,
                    o,
                    Math.max(
                      1,
                      Math.floor(
                        player.stats.projectileDamage / 6 + player.level / 2
                      )
                    )
                  )
                );
              }),
            Math.random() < player.stats.healOrbChance &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "heal"
                )
              ),
            Math.random() < player.stats.soulOrbChance &&
              orbs.push(
                new Orb(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  "soul"
                )
              );
        }
      }
      class LacaioDoVazio extends Enemy {
        constructor(wave) {
          super(wave);
          (this.width = 42),
            (this.height = 42),
            (this.speed = (0.7 + 0.3 * Math.random() * 0.6) * 0.85),
            (this.maxHp = Math.round(26 * this.scaleFactor)),
            (this.hp = this.maxHp),
            (this.damage = Math.round(6 * this.scaleFactor)),
            (this.expValue = Math.round(40 * this.scaleFactor)),
            (this.shootCooldown = 2400),
            (this.color = "#ff00ff"),
            (this.aiType = "standard");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo2.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage
            )
          );
        }
      }
      class GuardiaoAnomalo extends Enemy {
        constructor(wave) {
          super(wave),
            (this.width = 60),
            (this.height = 60),
            (this.speed = 0.35 * 0.6),
            (this.maxHp = Math.round(114 * this.scaleFactor));
          this.hp = this.maxHp;
          this.damage = Math.round(14 * this.scaleFactor);
          this.expValue = Math.round(180 * this.scaleFactor);
          (this.shootCooldown = 4200),
            (this.color = "#e67e22"),
            (this.aiType = "standard");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo3.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage,
              10,
              3
            )
          );
        }
      }
      class SentinelaEspectral extends Enemy {
        constructor(wave) {
          super(wave),
            (this.width = 30),
            (this.height = 30),
            (this.speed = 1.1 * 0.6),
            (this.maxHp = Math.round(18 * this.scaleFactor));
          this.hp = this.maxHp;
          this.damage = Math.round(9 * this.scaleFactor);
          this.expValue = Math.round(85 * this.scaleFactor);
          (this.shootCooldown = 1600),
            (this.color = "#2ecc71"),
            (this.aiType = "sniper");
        }
        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "red"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(this.x, this.y, this.width, this.height);
          }
          const e = spriteImages["inimigo1.png"];
          e &&
            e.complete &&
            ctx.drawImage(e, this.x, this.y, this.width, this.height);
        }
        shoot() {
          const e = Math.atan2(
            player.y - this.y - this.height / 2,
            player.x + player.width / 2 - this.x - this.width / 2
          );
          eProjs.push(
            new EnemyProjectile(
              this.x + this.width / 2,
              this.y + this.height / 2,
              e,
              this.damage,
              4,
              8
            )
          );
        }
      }
      class EliteEnemy extends GuardiaoAnomalo {
        constructor(wave) {
          super(wave);
          this.width *= 1.5;
          this.height *= 1.5;
          this.maxHp *= 2;
          this.hp = this.maxHp;
          this.damage *= 2;
          this.expValue *= 3;
          this.color = "#ffd700";
          this.shootCooldown *= 0.33;
        }
        draw() {
          super.draw();
        }
        die() {
          super.die();
          player.gainExp(player.expToNextLevel * 1.1);
          player.rerollsLeft++;
          createExplosion(
            this.x + this.width / 2,
            this.y + this.height / 2,
            this.color,
            50
          );
        }
      }
      class BossEnemy extends Enemy {
        constructor(hp, wave) {
          super(wave);
          this.width = 150;
          this.height = 150;
          this.speed = 0.5 * 0.6;
          this.maxHp = hp *2;
          this.hp = this.maxHp;
          this.damage = Math.round(25 * this.scaleFactor);
          this.expValue = Math.round(1000 * this.scaleFactor);
          this.color = "#e74c3c";
          this.aiType = "boss";
          this.attackPattern = ["shotgun", "rain", "dash"];
          this.currentAttack = 0;
          this.attackTimer = 0;
          this.attackCooldown = 400 + Math.random() * 400;
        }

        update(e) {
          super.update(e);
          this.attackTimer += e;
          if (this.attackTimer >= this.attackCooldown) {
            this.executeAttack();
            this.attackTimer = 0;
            this.currentAttack =
              (this.currentAttack + 1) % this.attackPattern.length;
          }
        }

        die() {
          super.die();
          player.gainRandomRareUpgrade();
          if (!undergoingBossDefeatTransition) {
            undergoingBossDefeatTransition = true;
            gameState = "transitioning";

            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            createExplosion(
              centerX,
              centerY,
              this.color || "#ff0000",
              80,
              8,
              90,
              1,
              0.5
            );
            createExplosion(
              centerX,
              centerY,
              "rgba(255, 200, 100, 0.8)",
              60,
              6,
              120,
              0.8,
              0.6
            );
            createExplosion(
              centerX,
              centerY,
              "rgba(255, 255, 255, 0.9)",
              40,
              10,
              60,
              0.6,
              0.3
            );

            let shakeDuration = 800;
            let shakeMagnitude = 10;
            let shakeStartTime = performance.now();

            function applyShake() {
              const elapsedTime = performance.now() - shakeStartTime;
              if (elapsedTime < shakeDuration) {
                const progress = elapsedTime / shakeDuration;
                const currentMagnitude = shakeMagnitude * (1 - progress);
                const x = (Math.random() - 0.5) * 2 * currentMagnitude;
                const y = (Math.random() - 0.5) * 2 * currentMagnitude;
                canvas.style.transform = `translate(${x}px, ${y}px)`;
                requestAnimationFrame(applyShake);
              } else {
                canvas.style.transform = "translate(0px, 0px)";
              }
            }
            applyShake();

            const transitionOverlay = d.getElementById(
              "sceneTransitionOverlay"
            );

            setTimeout(() => {
              transitionOverlay.style.visibility = "visible";
              transitionOverlay.style.opacity = "1";
            }, 600);

            setTimeout(() => {
              currentStarfieldConfig++;
              Starfield.init();

              const groundColors = ["#2a1a3a", "#3a2a1a", "#1a3a2a", "#3a3a1a"];
              const groundStrokeColors = [
                "#b6599b",
                "#b69b59",
                "#59b69b",
                "#9bb659",
              ];
              const colorIndex = currentStarfieldConfig % groundColors.length;
              currentGroundColor = groundColors[colorIndex];
              currentGroundStrokeColor = groundStrokeColors[colorIndex];

              generateGround();
              generatePlatforms();

              transitionOverlay.style.opacity = "0";
              const onTransitionEnd = () => {
                transitionOverlay.style.visibility = "hidden";
                transitionOverlay.removeEventListener(
                  "transitionend",
                  onTransitionEnd
                );

                if (player.isLevelingUp) {
                  player.exp += 50;
                } else {
                  player.exp = player.expToNextLevel;
                  player.isLevelingUp = true;
                  d.getElementById("exp-bar").style.backgroundColor = "#3498db";
                  d.getElementById("exp-bar").style.width = "100%";
                  const expText = d.getElementById("exp-bar-text");
                  if (expText)
                    expText.innerText = `${player.expToNextLevel}/${player.expToNextLevel} (100%)`;
                }

                if (gameState === "playing" || gameState === "transitioning") {
                  player.performLevelUpActions();
                }

                undergoingBossDefeatTransition = false;

                if (gameState !== "levelUp") {
                  gameState = "playing";
                  lastTime = performance.now();
                  requestAnimationFrame(gameLoop);
                }
              };
              transitionOverlay.addEventListener(
                "transitionend",
                onTransitionEnd
              );
              setTimeout(onTransitionEnd, 1500);
            }, 1300);
          }
        }

        executeAttack() {
          const attackType = this.attackPattern[this.currentAttack];
          if (attackType === "shotgun") {
            const angleToPlayer = Math.atan2(
              player.y - this.y,
              player.x - this.x
            );
            for (let i = -2; i <= 2; i++) {
              const angle = angleToPlayer + i * (Math.PI / 18);
              eProjs.push(
                new EnemyProjectile(
                  this.x + this.width / 2,
                  this.y + this.height / 2,
                  angle,
                  this.damage * 0.7,
                  8
                )
              );
            }
          } else if (attackType === "rain") {
            for (let i = 0; i < 10; i++) {
              const spawnX = Math.random() * canvas.width;
              eProjs.push(
                new EnemyProjectile(
                  spawnX,
                  -20,
                  Math.PI / 2,
                  this.damage * 0.5,
                  6,
                  5
                )
              );
            }
          } else if (attackType === "dash") {
            const angleToPlayer = Math.atan2(
              player.y - this.y,
              player.x - this.x
            );
            this.vx = Math.cos(angleToPlayer) * this.speed * 5;
            this.vy = Math.sin(angleToPlayer) * this.speed * 5;
            setTimeout(() => {
              this.vx = 0;
              this.vy = 0;
            }, 500);
          }
        }

        draw() {
          this.drawHealthBar();
          this.drawHitFlash();
          const img = spriteImages["inimigo3.png"];
          if (img && img.complete) {
            ctx.drawImage(img, this.x, this.y, this.width, this.height);
            ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
            ctx.beginPath();
            ctx.arc(
              this.x + this.width / 2,
              this.y + this.height / 2,
              this.width / 2,
              0,
              2 * Math.PI
            );
            ctx.fill();
          }
        }

        shoot() {}
      }
      class ErraticLurker extends LacaioDoVazio {
        constructor(wave) {
          super(wave);
          this.auraColor = "rgba(150, 50, 200, 0.4)";
          this.erraticMoveTimer = 0;
          this.erraticInterval = 300 + Math.random() * 400;
          this.currentMoveAngle = Math.random() * Math.PI * 2;
          this.speed *= 1.2;
          this.turnCooldown = 0;
          this.timeToTurn = 100;
        }

        update(e) {
          if ("descending" === this.state) {
            this.y += this.speed * 0.5;
            if (this.y > this.chaseHeight) {
              this.state = "chasing";
              this.erraticMoveTimer = this.erraticInterval;
            }
            return;
          } else if ("chasing" === this.state) {
            this.erraticMoveTimer -= e;
            if (this.erraticMoveTimer <= 0) {
              const angleToPlayer = Math.atan2(
                player.y - this.y,
                player.x - this.x
              );
              this.currentMoveAngle =
                angleToPlayer + (Math.random() - 0.5) * Math.PI;
              this.erraticMoveTimer = this.erraticInterval;
            }

            let separationForceX = 0;
            enemies.forEach((other) => {
              if (other === this || other.hp <= 0) return;
              const dist = Math.hypot(this.x - other.x, this.y - other.y);
              const minDist = this.width / 2 + other.width / 2 + 10;
              if (dist < minDist && dist > 0) {
                separationForceX += (this.x - other.x) / dist;
              }
            });

            this.x +=
              Math.cos(this.currentMoveAngle) * this.speed * this.slowFactor +
              separationForceX * 0.5 * this.speed;
            this.y +=
              Math.sin(this.currentMoveAngle) *
              this.speed *
              this.slowFactor *
              0.7;

            const MIN_Y_ERRATIC = 20;
            const MAX_Y_ERRATIC = canvas.height - 50 - this.height;

            if (this.x < 0) {
              this.x = 0;
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
            } else if (this.x + this.width > canvas.width) {
              this.x = canvas.width - this.width;
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
            }

            if (this.y < MIN_Y_ERRATIC) {
              this.y = MIN_Y_ERRATIC;
              this.currentMoveAngle *= -1;
            } else if (this.y > MAX_Y_ERRATIC) {
              this.y = MAX_Y_ERRATIC;
              this.currentMoveAngle *= -1;
            }
            this.currentMoveAngle =
              ((this.currentMoveAngle % (2 * Math.PI)) + 2 * Math.PI) %
              (2 * Math.PI);

            this.shootTimer += e;
            if (this.shootTimer >= this.shootCooldown) {
              super.shoot();
              this.shootTimer = 0;
            }
          }
          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
        }

        draw() {
          super.draw();
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = this.auraColor;
          ctx.beginPath();
          ctx.arc(
            this.x + this.width / 2,
            this.y + this.height / 2,
            this.width * 0.7,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.restore();
        }
      }
      class DashingPhantom extends LacaioDoVazio {
        constructor(wave) {
          super(wave);
          this.auraColor = "rgba(230, 230, 50, 0.4)";
          this.dashCooldown = 0;
          this.dashInterval = 2000 + Math.random() * 1500;
          this.isDashing = false;
          this.dashDuration = 200;
          this.dashTimer = 0;
          this.dashSpeed = this.speed * 3;
          this.turnCooldown = 0;
          this.timeToTurn = 200;
          this.currentMoveAngle = Math.atan2(
            player.y - this.y,
            player.x - this.x
          );
        }

        update(e) {
          if ("descending" === this.state) {
            this.y += this.speed * 0.5;
            if (this.y > this.chaseHeight) {
              this.state = "chasing";
              this.dashCooldown = this.dashInterval / 2;
            }
            return;
          } else if ("chasing" === this.state) {
            this.dashCooldown -= e;

            let separationForceX = 0;
            let separationForceY = 0;
            enemies.forEach((other) => {
              if (other === this || other.hp <= 0) return;
              const dist = Math.hypot(this.x - other.x, this.y - other.y);
              const minDist = this.width / 2 + other.width / 2 + 10;
              if (dist < minDist && dist > 0) {
                const forceFactor = (minDist - dist) / minDist;
                separationForceX += ((this.x - other.x) / dist) * forceFactor;
                separationForceY += ((this.y - other.y) / dist) * forceFactor;
              }
            });
            const maxSeparation = 1.0;
            separationForceX = Math.max(
              -maxSeparation,
              Math.min(maxSeparation, separationForceX)
            );
            separationForceY = Math.max(
              -maxSeparation,
              Math.min(maxSeparation, separationForceY)
            );

            if (this.isDashing) {
              this.x +=
                Math.cos(this.currentMoveAngle) *
                this.dashSpeed *
                this.slowFactor;
              this.dashTimer -= e;
              if (this.dashTimer <= 0) {
                this.isDashing = false;
                this.dashCooldown = this.dashInterval;
              }
            } else {
              if (
                this.dashCooldown <= 0 &&
                Math.abs(this.y - player.y) < this.height * 2
              ) {
                this.isDashing = true;
                this.dashTimer = this.dashDuration;
                this.currentMoveAngle = player.x < this.x ? Math.PI : 0;
              } else {
                const targetY = player.y + player.height / 2 - this.height / 2;
                const targetX = player.x + (player.x < this.x ? 200 : -200);

                const angleToTarget = Math.atan2(
                  targetY - this.y,
                  targetX - this.x
                );
                this.currentMoveAngle = angleToTarget;

                this.x +=
                  Math.cos(this.currentMoveAngle) *
                    this.speed *
                    this.slowFactor +
                  separationForceX * this.speed * 0.5;
                this.y +=
                  Math.sin(this.currentMoveAngle) *
                    this.speed *
                    this.slowFactor *
                    0.8 +
                  separationForceY * this.speed * 0.4;
              }
            }

            const MIN_Y_DASHER = 50;
            const MAX_Y_DASHER = canvas.height - this.height - 50;

            if (this.x < 0) {
              this.x = 0;
              if (this.isDashing) this.isDashing = false;
            } else if (this.x + this.width > canvas.width) {
              this.x = canvas.width - this.width;
              if (this.isDashing) this.isDashing = false;
            }

            if (this.y < MIN_Y_DASHER) {
              this.y = MIN_Y_DASHER;
            } else if (this.y > MAX_Y_DASHER) {
              this.y = MAX_Y_DASHER;
            }

            this.shootTimer += e;
            if (this.shootTimer >= this.shootCooldown * 1.5) {
              super.shoot();
              this.shootTimer = 0;
            }
          }
          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
        }

        draw() {
          super.draw();
          if (this.auraColor && this.state !== "descending") {
            ctx.save();
            ctx.globalAlpha = this.isDashing ? 0.9 : 0.7;
            ctx.fillStyle = this.auraColor;
            ctx.beginPath();
            const auraWidth = this.isDashing
              ? this.width * 1.2
              : this.width * 0.8;
            const auraHeight = this.isDashing
              ? this.height * 0.6
              : this.height * 0.8;
            ctx.ellipse(
              this.x + this.width / 2,
              this.y + this.height / 2,
              auraWidth,
              auraHeight,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.restore();
          }
        }
      }
      class OrbiterEnemy extends LacaioDoVazio {
        constructor(wave) {
          super(wave);
          this.aiType = "orbiter";
          this.currentMoveAngle = Math.random() * Math.PI * 2;
          this.turnCooldown = 0;
          this.timeToTurn = 700 + Math.random() * 600;
          this.orbitRadius = 200 + Math.random() * 150;
          this.speed *= 0.9;
          this.auraColor = "rgba(0, 200, 200, 0.4)";
        }

        update(e) {
          if ("descending" === this.state) {
            this.y += this.speed;
            if (this.y > this.chaseHeight * 0.8) {
              this.state = "chasing";
              this.currentMoveAngle = Math.atan2(
                player.y - this.y,
                player.x - this.x
              );
            }
            return;
          } else if ("chasing" === this.state) {
            let separationX = 0;
            let separationY = 0;
            const SEPARATION_BUFFER = 8;
            enemies.forEach((otherEnemy) => {
              if (otherEnemy === this || otherEnemy.hp <= 0) return;
              const dx = this.x - otherEnemy.x;
              const dy = this.y - otherEnemy.y;
              const distance = Math.hypot(dx, dy);
              const thisRadius = (this.width + this.height) / 4;
              const otherRadius = (otherEnemy.width + otherEnemy.height) / 4;
              const combinedRadius =
                thisRadius + otherRadius + SEPARATION_BUFFER;
              if (distance < combinedRadius && distance > 0) {
                const overlap = combinedRadius - distance;
                const pushX = dx / distance;
                const pushY = dy / distance;
                separationX += pushX * (overlap / combinedRadius) * 1.5;
                separationY += pushY * (overlap / combinedRadius) * 1.5;
              }
            });
            const sepMagnitude = Math.hypot(separationX, separationY);
            if (sepMagnitude > 1.0) {
              separationX /= sepMagnitude;
              separationY /= sepMagnitude;
            }

            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            const distToPlayer = Math.hypot(
              this.x - playerCenterX,
              this.y - playerCenterY
            );
            let targetAngleToPlayer = Math.atan2(
              playerCenterY - this.y,
              playerCenterX - this.x
            );

            this.turnCooldown -= e;
            if (this.turnCooldown <= 0) {
              let desiredAngle;
              if (distToPlayer > this.orbitRadius + 50) {
                desiredAngle = targetAngleToPlayer;
              } else if (distToPlayer < this.orbitRadius - 50) {
                desiredAngle = targetAngleToPlayer + Math.PI;
              } else {
                desiredAngle =
                  targetAngleToPlayer +
                  (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
              }

              let angleDiff = desiredAngle - this.currentMoveAngle;
              while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
              while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

              const turnSpeed = 0.03 + this.wave * 0.002;
              if (Math.abs(angleDiff) > turnSpeed) {
                this.currentMoveAngle += Math.sign(angleDiff) * turnSpeed;
              } else {
                this.currentMoveAngle = desiredAngle;
              }
              this.turnCooldown = this.timeToTurn * (0.3 + Math.random() * 0.4);
            }

            if (this.turnCooldown > this.timeToTurn * 0.2) {
              this.currentMoveAngle += (Math.random() - 0.5) * 0.05;
            }

            let moveX =
              Math.cos(this.currentMoveAngle) * this.speed * this.slowFactor;
            let moveY =
              Math.sin(this.currentMoveAngle) * this.speed * this.slowFactor;

            this.x += moveX + separationX * this.speed * 0.7;
            this.y += moveY + separationY * this.speed * 0.7;

            const MIN_Y_ORBITER = 40;
            let bounced = false;
            if (this.x < 0) {
              this.x = 0;
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
              bounced = true;
            } else if (this.x + this.width > canvas.width) {
              this.x = canvas.width - this.width;
              this.currentMoveAngle = Math.PI - this.currentMoveAngle;
              bounced = true;
            }
            if (this.y < MIN_Y_ORBITER) {
              this.y = MIN_Y_ORBITER;
              if (Math.sin(this.currentMoveAngle) < 0)
                this.currentMoveAngle *= -1;
              bounced = true;
            }

            const groundY = getGroundHeight(this.x + this.width / 2);
            if (this.y + this.height > groundY - this.height * 0.3) {
              this.y = groundY - this.height * 0.3 - this.height;
              if (Math.sin(this.currentMoveAngle) > 0)
                this.currentMoveAngle *= -1;
              bounced = true;
            }
            if (bounced) {
              this.currentMoveAngle =
                ((this.currentMoveAngle % (2 * Math.PI)) + 2 * Math.PI) %
                (2 * Math.PI);
              this.turnCooldown = this.timeToTurn * 0.3;
            }

            this.shootTimer += e;
            if (this.shootTimer >= this.shootCooldown) {
              super.shoot();
              this.shootTimer = 0;
            }
          }
          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
        }

        draw() {
          super.draw();
          if (this.auraColor && this.state !== "descending") {
            ctx.save();
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = this.auraColor;
            ctx.beginPath();
            const auraVisualRadius = Math.max(this.width, this.height) * 0.5;
            ctx.arc(
              this.x + this.width / 2,
              this.y + this.height / 2,
              auraVisualRadius,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.restore();
          }
        }
      }
      class GroundSkulker extends LacaioDoVazio {
        constructor(wave) {
          super(wave);
          this.auraColor = "rgba(128, 128, 128, 0.5)";
          this.burrowDepth = 150 + Math.random() * 100;
          this.isBurrowed = false;
          this.riseSpeed = this.speed * 2;
          this.burrowCooldown = 0;
          this.burrowInterval = 3000 + Math.random() * 2000;
          this.attackHeightOffset = -(this.height * 1.5);
          this.speed *= 0.8;
          this.shootCooldown *= 1.5;
          this.state = "seeking_burrow_spot";
          this.targetBurrowX = player.x;
        }

        update(e) {
          this.burrowCooldown -= e;

          let separationX = 0;
          enemies.forEach((other) => {
            if (other === this || other.hp <= 0) return;
            const dist = Math.hypot(this.x - other.x, this.y - other.y);
            const minDist = this.width / 2 + other.width / 2 + 15;
            if (dist < minDist && dist > 0) {
              separationX +=
                ((this.x - other.x) / dist) * ((minDist - dist) / minDist);
            }
          });
          if (Math.abs(separationX) > 1) separationX = Math.sign(separationX);
          this.x += separationX * this.speed * 0.5 * this.slowFactor;

          if (this.state === "seeking_burrow_spot") {
            this.targetBurrowX = player.x + (Math.random() - 0.5) * 100;
            const targetGroundY =
              getGroundHeight(this.targetBurrowX + this.width / 2) +
              this.burrowDepth * 0.2;

            const angleToTarget = Math.atan2(
              targetGroundY - this.y,
              this.targetBurrowX - this.x
            );

            this.x +=
              Math.cos(angleToTarget) * this.speed * 0.6 * this.slowFactor;
            this.y +=
              Math.sin(angleToTarget) * this.speed * 0.6 * this.slowFactor;

            if (this.y < this.chaseHeight * 0.8)
              this.y = this.chaseHeight * 0.8;
            if (this.y > canvas.height) this.y = canvas.height;

            if (
              Math.abs(this.x - this.targetBurrowX) < this.width * 1.5 &&
              this.burrowCooldown <= 0 &&
              this.y + this.height > player.y
            ) {
              this.state = "burrowing";
              this.isBurrowed = true;
              soundManager.playSound(100, 20, 0.5, "sawtooth", 0.3);
              soundManager.playNoise(0.5, 200, 0.2, "lowpass");
            }
          } else if (this.state === "burrowing") {
            this.y += this.riseSpeed * 1.5 * this.slowFactor;
            if (this.y > canvas.height + this.height) {
              this.state = "waiting_below";
              this.x = player.x + (Math.random() - 0.5) * (canvas.width / 3);
              this.x = Math.max(
                this.width,
                Math.min(this.x, canvas.width - this.width * 2)
              );
              this.burrowCooldown = this.burrowInterval * 0.5;
            }
          } else if (this.state === "waiting_below") {
            if (this.burrowCooldown <= 0) {
              this.state = "rising_to_attack";
              this.y = canvas.height + this.height;
              this.x = player.x + (Math.random() - 0.5) * 50 - this.width / 2;
              this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
            }
          } else if (this.state === "rising_to_attack") {
            this.y -= this.riseSpeed * this.slowFactor;
            const targetAttackY = player.y + this.attackHeightOffset;
            if (this.y <= targetAttackY) {
              this.y = targetAttackY;
              this.state = "attacking_from_below";
              this.shootTimer = 0;
            }
          } else if (this.state === "attacking_from_below") {
            const targetX = player.x + player.width / 2 - this.width / 2;
            this.x +=
              Math.sign(targetX - this.x) * this.speed * 0.3 * this.slowFactor;

            this.shootTimer += e;
            if (this.shootTimer >= this.shootCooldown) {
              eProjs.push(
                new EnemyProjectile(
                  this.x + this.width / 2,
                  this.y,
                  -Math.PI / 2,
                  this.damage
                )
              );
              this.shootTimer = 0;
              this.state = "retreating";
              this.burrowCooldown = this.burrowInterval;
            }
          } else if (this.state === "retreating") {
            this.y += this.speed * 1.2 * this.slowFactor;
            if (this.y > canvas.height + this.height) {
              this.state = "seeking_burrow_spot";
              this.isBurrowed = false;
            }
          }

          if (this.hitFlashTimer > 0) this.hitFlashTimer -= e;
          if (!this.isBurrowed && this.y + this.height < canvas.height) {
            if (checkCollision(this, player)) {
              player.takeDamage(this.damage);
            }
          }
        }

        draw() {
          if (
            !this.isBurrowed ||
            this.state === "rising_to_attack" ||
            this.state === "attacking_from_below"
          ) {
            super.draw();
            if (this.auraColor) {
              ctx.save();
              ctx.globalAlpha = 0.4;
              ctx.fillStyle = this.auraColor;
              ctx.beginPath();
              const auraVisualRadius = Math.max(this.width, this.height) * 0.5;
              ctx.arc(
                this.x + this.width / 2,
                this.y + this.height / 2,
                auraVisualRadius,
                0,
                Math.PI * 2
              );
              ctx.fill();
              ctx.restore();
            }
          } else if (this.isBurrowed && this.state === "waiting_below") {
            ctx.save();
            const groundY = getGroundHeight(this.x + this.width / 2);
            const disturbanceRadius = this.width * 0.4;
            ctx.fillStyle = "rgba(100, 80, 50, 0.5)";
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
              ctx.arc(
                this.x +
                  this.width / 2 +
                  (Math.random() - 0.5) * disturbanceRadius * 0.5,
                groundY - 5 - Math.random() * 5,
                disturbanceRadius * (0.5 + Math.random() * 0.5),
                0,
                Math.PI * 2
              );
            }
            ctx.fill();
            ctx.restore();
          }
        }
        die() {
          this.isBurrowed = false;
          super.die();
        }
      }
      const ENEMY_TYPES = {};
      ENEMY_TYPES.LacaioDoVazio = LacaioDoVazio;
      ENEMY_TYPES.GuardiaoAnomalo = GuardiaoAnomalo;
      ENEMY_TYPES.SentinelaEspectral = SentinelaEspectral;
      ENEMY_TYPES.EliteEnemy = EliteEnemy;
      ENEMY_TYPES.BossEnemy = BossEnemy;
      ENEMY_TYPES.ErraticLurker = ErraticLurker;
      ENEMY_TYPES.DashingPhantom = DashingPhantom;
      ENEMY_TYPES.GroundSkulker = GroundSkulker;
      ENEMY_TYPES.OrbiterEnemy = OrbiterEnemy;
      class Projectile {
        constructor(e, t, o, i, s = 8) {
          (this.x = e),
            (this.y = t),
            (this.angle = o),
            (this.damage = i),
            (this.speed = s),
            (this.vx = Math.cos(o) * this.speed),
            (this.vy = Math.sin(o) * this.speed),
            (this.active = !0);
        }
        update() {
          (this.x += this.vx), (this.y += this.vy);
          if (this.y >= getGroundHeight(this.x)) {
            this.active = !1;
            let e = "#fff";
            this instanceof PlayerProjectile && (e = "#00ffff"),
              this instanceof EnemyProjectile && (e = "#ff0000"),
              createExplosion(this.x, this.y, e);
          }
          this.isOffScreen() && (this.active = !1);
        }
        isOffScreen() {
          return (
            this.x < 0 ||
            this.x > canvas.width ||
            this.y < 0 ||
            this.y > canvas.height
          );
        }
      }

      function calculateWaveHP(waveDef) {
        let totalHP = 0;
        for (const enemyName in waveDef.enemies) {
          const count = waveDef.enemies[enemyName];
          if (ENEMY_TYPES[enemyName]) {
            const tempEnemy = new ENEMY_TYPES[enemyName]();
            totalHP += tempEnemy.maxHp * count;
          }
        }
        return totalHP > 0 ? totalHP : 500;
      }
      class PlayerProjectile extends Projectile {
        constructor(e, t, o, i = null, s = !1) {
          super(e, t, o, void 0, player.stats.projectileSpeed),
            (this.radius = player.stats.projectileSize),
            (this.pierceLeft = player.stats.projectilePierce),
            (this.explosive = s),
            (this.trail = []);
          this.hitEnemies = new Set();
          let n = null !== i ? i : player.stats.projectileDamage;
          player.stats.rage &&
            player.hp < player.stats.maxHp / 2 &&
            (n *= 1 + (1 - player.hp / (player.stats.maxHp / 2)) * 0.5),
            (this.isCrit = Math.random() < player.stats.critChance),
            this.isCrit && (n *= player.stats.critDamage),
            (this.damage = n);
          this.jumpsLeft = player.stats.chainJumps;
        }
        update() {
          super.update();
          const trailColor = this.isCrit ? "#f1c40f" : "#00ffff";
          particles.push(new Particle(this.x, this.y, trailColor, 0.5, 20));
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > 5) {
            this.trail.shift();
          }
        }
        draw() {
          ctx.save();
          for (let i = 0; i < this.trail.length; i++) {
            const pos = this.trail[i];
            const opacity = (i / this.trail.length) * 0.8;
            const radius = this.radius * (i / this.trail.length);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
            ctx.fill();
          }
          ctx.restore();

          if (gameData.showHitboxes) {
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 1;
            ctx.strokeRect(
              this.x - this.radius,
              this.y - this.radius,
              2 * this.radius,
              2 * this.radius
            );
          }

          ctx.save();
          ctx.shadowColor = this.isCrit ? "#f1c40f" : "#00ffff";
          ctx.shadowBlur = 15;

          ctx.fillStyle = this.isCrit ? "#f1c40f" : "#00ffff";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
          ctx.fill();

          ctx.restore();

          if (this.explosive) {
            ctx.strokeStyle = "#e67e22";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 2, 0, 2 * Math.PI);
            ctx.stroke();
          }
        }
        onHit(e) {
          if (!this.active || this.hitEnemies.has(e)) return;

          e.takeDamage(this.damage, this.isCrit);
          this.hitEnemies.add(e);

          if (player.stats.lifeSteal > 0)
            player.heal(this.damage * player.stats.lifeSteal);
          if (player.stats.cold)
            e.slowFactor = Math.max(0.2, e.slowFactor * 0.99);
          if (player.stats.wound) e.bleedDamage += 0.1 * this.damage;
          if (
            player.stats.collateralBeamChance > 0 &&
            Math.random() < player.stats.collateralBeamChance
          ) {
            const laserStartY = e.y + e.height / 2;
            const laserDamage =
              player.stats.projectileDamage *
              player.stats.collateralBeamDamageFactor;
            const laserThicknessForHit = 15;

            particles.push(
              new HorizontalLaserEffect(
                e.x + e.width / 2,
                laserStartY,
                Math.PI,
                canvas.width
              )
            );
            particles.push(
              new HorizontalLaserEffect(
                e.x + e.width / 2,
                laserStartY,
                0,
                canvas.width
              )
            );

            enemies.forEach((otherEnemy) => {
              if (otherEnemy.hp > 0 && otherEnemy !== e) {
                const otherEnemyCenterY = otherEnemy.y + otherEnemy.height / 2;
                if (
                  Math.abs(otherEnemyCenterY - laserStartY) <
                  otherEnemy.height / 2 + laserThicknessForHit
                ) {
                  otherEnemy.takeDamage(laserDamage, false);
                }
              }
            });
            soundManager.playSound(1200, 200, 0.2, "sawtooth", 0.25);
          }
          if (this.jumpsLeft > 0) {
            this.jumpsLeft--;
            let closestEnemy = null;
            let minDistance = Infinity;
            for (const otherEnemy of enemies) {
              if (
                otherEnemy !== e &&
                otherEnemy.hp > 0 &&
                !this.hitEnemies.has(otherEnemy)
              ) {
                const distance = Math.hypot(
                  this.x - otherEnemy.x,
                  this.y - otherEnemy.y
                );
                if (distance < minDistance) {
                  minDistance = distance;
                  closestEnemy = otherEnemy;
                }
              }
            }
            if (closestEnemy) {
              const newAngle = Math.atan2(
                closestEnemy.y + closestEnemy.height / 2 - this.y,
                closestEnemy.x + closestEnemy.width / 2 - this.x
              );
              this.angle = newAngle;
              this.vx = Math.cos(newAngle) * this.speed;
              this.vy = Math.sin(newAngle) * this.speed;
              this.damage *= 0.3;
              return;
            }
          }

          if (this.pierceLeft > 1) {
            this.damage *= 0.8;
          }

          this.pierceLeft--;
          if (this.pierceLeft < 1) {
            this.active = false;
          }
        }
      }
      class EnemyProjectile extends Projectile {
        constructor(e, t, o, i, s = 5, n = 4 * 0.6) {
          super(e, t, o, i, n), (this.radius = s);
        }
        draw() {
          if (gameData.showHitboxes) {
            (ctx.strokeStyle = "#ff8888"),
              (ctx.lineWidth = 1),
              ctx.strokeRect(
                this.x - this.radius,
                this.y - this.radius,
                2 * this.radius,
                2 * this.radius
              );
          }
          (ctx.fillStyle = "#ff0000"),
            (ctx.strokeStyle = "#fff"),
            (ctx.lineWidth = 1),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
            ctx.fill(),
            ctx.stroke();
        }
      }
      class Particle {
        constructor(e, t, o, speedMultiplier = 1, life = 50) {
          (this.x = e),
            (this.y = t),
            (this.color = o),
            (this.radius = 3 * Math.random() + 1),
            (this.vx = (Math.random() - 0.5) * speedMultiplier),
            (this.vy = (Math.random() - 0.5) * speedMultiplier),
            (this.life = Math.max(10, life));
        }
        update() {
          (this.x += this.vx),
            (this.y += this.vy),
            (this.vy += 0.1),
            this.life--;
        }
        draw() {
          (ctx.globalAlpha = this.life / 50),
            (ctx.fillStyle = this.color),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
            ctx.fill(),
            (ctx.globalAlpha = 1);
        }
      }
      function createExplosion(
        e,
        t,
        o = "#fff",
        count = 15,
        baseSpeed = 4,
        life = 50,
        speedVariation = 0.5,
        lifeVariation = 0.5
      ) {
        for (let s = 0; s < count; s++) {
          const speedMult =
            baseSpeed * (1 + (Math.random() - 0.5) * speedVariation);
          const particleLife =
            life * (1 + (Math.random() - 0.5) * lifeVariation);
          particles.push(new Particle(e, t, o, speedMult, particleLife));
        }
      }
      class HorizontalLaserEffect {
        constructor(x, y, angle, length) {
          this.x = x;
          this.y = y;
          this.angle = angle;
          this.length = length * 10;
          this.life = 15;
          this.maxWidth = 8 + Math.random() * 5;
        }
        update() {
          this.life--;
        }
        draw() {
          if (this.life <= 0) return;
          const alpha = this.life / 15;
          const currentWidth = this.maxWidth * (this.life / 15);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(this.x, this.y - currentWidth / 2);
          ctx.lineTo(
            this.x + Math.cos(this.angle) * this.length,
            this.y - currentWidth / 2
          );
          ctx.lineTo(
            this.x + Math.cos(this.angle) * this.length,
            this.y + currentWidth / 2
          );
          ctx.lineTo(this.x, this.y + currentWidth / 2);
          ctx.closePath();

          ctx.fillStyle = `rgba(0, 220, 255, ${alpha * 0.7})`;
          ctx.shadowColor = "rgba(0, 220, 255, 0.5)";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.restore();
        }
      }
      class Orb {
        constructor(e, t, o) {
          (this.x = e),
            (this.y = t),
            (this.type = o),
            (this.radius = 8),
            (this.color =
              "heal" === o ? "lime" : "soul" === o ? "violet" : "#add8e6"),
            (this.vy = -2),
            (this.life = 2000),
            (this.onGround = !1);
        }
        update() {
          this.onGround || ((this.y += this.vy), (this.vy += 0.035)),
            this.life--;
          const e = getGroundHeight(this.x);
          this.y + this.radius > e
            ? ((this.y = e - this.radius), (this.vy = 0), (this.onGround = !0))
            : (this.onGround = !1);
          const t = player.x + player.width / 2 - this.x,
            o = player.y + player.height / 2 - this.y,
            i = Math.hypot(t, o);
          i < 150 && ((this.x += (t / i) * 5), (this.y += (o / i) * 5)),
            checkCollision(
              {
                x: this.x - this.radius,
                y: this.y - this.radius,
                width: 2 * this.radius,
                height: 2 * this.radius,
              },
              player
            ) && this.collect();
        }
        draw() {
          if ("soul_currency" === this.type || "soul" === this.type) {
            const e = spriteImages["alma.png"];
            e && e.complete
              ? ctx.drawImage(e, this.x - 16, this.y - 16, 28, 28)
              : ((ctx.fillStyle = this.color),
                ctx.beginPath(),
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
                ctx.fill());
          } else
            (ctx.fillStyle = this.color),
              ctx.beginPath(),
              ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI),
              ctx.fill(),
              (ctx.strokeStyle = "white"),
              (ctx.lineWidth = 1),
              ctx.stroke();
        }
        collect() {
          if ("heal" === this.type)
            player.heal(0.1 * player.stats.maxHp), soundManager.playHealSound();
          else if ("soul" === this.type)
            player.gainExp(50), soundManager.playCollectOrbSound();
          else if ("soul_currency" === this.type) {
            (gameData.totalSouls += 1),
              (runSouls += 1),
              soundManager.playCollectOrbSound();
            const e = d.getElementById("soul-popup"),
              t = d.getElementById("soul-popup-text");
            (t.innerText = `: ${runSouls}`),
              e.classList.add("active"),
              soulPopupTimer && clearTimeout(soulPopupTimer),
              (soulPopupTimer = setTimeout(() => {
                e.classList.remove("active");
              }, 2e3));
          } else soundManager.playCollectOrbSound();
          this.life = 0;
        }
      }
      class Wisp {
        constructor(e) {
          (this.owner = e),
            (this.x = e.x - 50),
            (this.y = e.y),
            (this.angle = 0),
            (this.shootCooldown = 0);
          this.laserDamageTick = 0;
          this.laserTarget = null;
          this.laserVisualAngle = 0;
        }
        update(e) {
          this.angle += 0.02;
          const t =
              this.owner.x + this.owner.width / 2 + 75 * Math.cos(this.angle),
            o = this.owner.y + 75 * Math.sin(this.angle);
          (this.x += 0.1 * (t - this.x)),
            (this.y += 0.1 * (o - this.y)),
            this.shootCooldown > 0 && (this.shootCooldown -= e);
          this.laserDamageTick > 0 && (this.laserDamageTick -= e);

          if (
            this.owner.stats.laserBeam &&
            this.laserDamageTick <= 0 &&
            enemies.length > 0
          ) {
            this.laserDamageTick = 350;

            let closestEnemy = null;
            let minDistance = Infinity;
            enemies.forEach((enemy) => {
              if (enemy.hp > 0) {
                const distance = Math.hypot(
                  this.x - enemy.x - enemy.width / 2,
                  this.y - enemy.y - enemy.height / 2
                );
                if (distance < minDistance) {
                  minDistance = distance;
                  closestEnemy = enemy;
                }
              }
            });
            this.laserTarget = closestEnemy;

            if (this.laserTarget) {
              this.laserVisualAngle = Math.atan2(
                this.laserTarget.y + this.laserTarget.height / 2 - this.y,
                this.laserTarget.x + this.laserTarget.width / 2 - this.x
              );
              this.laserTarget.takeDamage(
                this.owner.stats.projectileDamage / 5,
                Math.random() < this.owner.stats.critChance
              );
            } else {
              this.laserTarget = null;
            }
          } else if (!this.owner.stats.laserBeam || enemies.length === 0) {
            this.laserTarget = null;
          }

          if (
            !this.laserTarget &&
            enemies.length > 0 &&
            this.shootCooldown <= 0
          ) {
            let i = enemies.reduce((e, t) =>
              Math.hypot(t.x - this.x, t.y - this.y) <
              Math.hypot(e.x - this.x, e.y - this.y)
                ? t
                : e
            );
            if (i) {
              this.shoot(i);
              this.shootCooldown = 2 * this.owner.stats.attackSpeed;
            }
          }
        }
        shoot(e) {
          const t = Math.atan2(
            e.y + e.height / 2 - this.y,
            e.x + e.width / 2 - this.x
          );
          pProjs.push(
            new PlayerProjectile(
              this.x,
              this.y,
              t,
              this.owner.stats.projectileDamage / 2
            )
          );
        }
        draw() {
          (ctx.fillStyle = "rgba(155,89,182,.8)"),
            (ctx.strokeStyle = "#fff"),
            (ctx.lineWidth = 1),
            ctx.beginPath(),
            ctx.arc(this.x, this.y, 10, 0, 2 * Math.PI),
            ctx.fill(),
            ctx.stroke();

          if (
            this.owner.stats.laserBeam &&
            this.laserTarget &&
            this.laserDamageTick > 350 - 50
          ) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            const laserDisplayLength =
              Math.hypot(
                this.laserTarget.x + this.laserTarget.width / 2 - this.x,
                this.laserTarget.y + this.laserTarget.height / 2 - this.y
              ) + 50;
            ctx.lineTo(
              this.x + Math.cos(this.laserVisualAngle) * laserDisplayLength,
              this.y + Math.sin(this.laserVisualAngle) * laserDisplayLength
            );
            ctx.strokeStyle = "rgba(200, 100, 255, 0.7)";
            ctx.lineWidth = 2 + Math.random();
            ctx.shadowColor = "rgba(200, 100, 255, 0.5)";
            ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.restore();
          }
        }
      }
      function formatTime(t) {
        const e = Math.floor(t / 6e4)
            .toString()
            .padStart(2, "0"),
          o = Math.floor((t % 6e4) / 1e3)
            .toString()
            .padStart(2, "0");
        return `${e}:${o}`;
      }
      const Leaderboard = {
        currentDifficulty: "Normal",
        getLeaderboardKey() {
          return `voidSurvivorLeaderboard_${this.currentDifficulty}`;
        },
        show() {
          this.loadAndDisplayScores("leaderboard-list");
          this.loadAndDisplayScores("leaderboard-list-main", true);
        },
        loadAndDisplayScores(elementId, isMainLeaderboardScreen = false) {
          const listElement = d.getElementById(elementId);
          if (!listElement) return;

          if (
            isMainLeaderboardScreen &&
            d.getElementById("leaderboardScreen").contains(listElement)
          ) {
            let selectorContainer = d.getElementById(
              "difficulty-selector-container"
            );
            if (!selectorContainer) {
              selectorContainer = d.createElement("div");
              selectorContainer.id = "difficulty-selector-container";
              selectorContainer.style.marginBottom = "15px";
              const title = d.createElement("p");
              title.innerText = "Ver Placar Para:";
              title.style.fontSize = "0.9em";
              selectorContainer.appendChild(title);

              const difficulties = ["Fácil", "Normal", "Difícil"];
              difficulties.forEach((diff) => {
                const btn = d.createElement("button");
                btn.className = "btn";
                btn.innerText = diff;
                btn.style.fontSize = "0.8em";
                btn.style.padding = "8px 12px";
                btn.onclick = () => {
                  soundManager.playUIClickSound();
                  this.currentDifficulty = diff;
                  this.loadAndDisplayScores("leaderboard-list-main", true);
                };
                if (diff === this.currentDifficulty) {
                  btn.style.borderColor = "#f1c40f";
                }
                selectorContainer.appendChild(btn);
              });
              const leaderboardContainer = listElement.closest(
                ".leaderboard-container"
              );
              if (leaderboardContainer) {
                leaderboardContainer.insertBefore(
                  selectorContainer,
                  leaderboardContainer.firstChild.nextSibling
                );
              } else {
                listElement.parentNode.insertBefore(
                  selectorContainer,
                  listElement
                );
              }
            }
            Array.from(
              selectorContainer.getElementsByTagName("button")
            ).forEach((btn) => {
              btn.style.borderColor =
                btn.innerText === this.currentDifficulty ? "#f1c40f" : "#fff";
            });
          }

          try {
            const key = this.getLeaderboardKey();
            const scoresData = localStorage.getItem(key);
            const scores = scoresData ? JSON.parse(scoresData) : [];
            listElement.innerHTML =
              0 === scores.length
                ? "<li>Nenhuma pontuação ainda. Seja o primeiro!</li>"
                : scores
                    .map(
                      (e) =>
                        `<li><span>${e.name}</span><span>${e.score}${
                          e.time ? ` (${formatTime(e.time)})` : ""
                        }</span></li>`
                    )
                    .join("");
          } catch (o) {
            listElement.innerHTML = "<li>Erro ao carregar pontuações.</li>";
            console.error(o);
          }
        },
        submitScore() {
          const e = d.getElementById("playerNameInput"),
            t = d.getElementById("submission-message"),
            o = e.value.trim();
          if (!o)
            return (
              (t.textContent = "Por favor, insira um nome."),
              void (t.className = "error")
            );
          d.getElementById("submitScoreBtn").disabled = !0;
          try {
            const key = this.getLeaderboardKey();
            const scoresData = localStorage.getItem(key);
            let s = scoresData ? JSON.parse(scoresData) : [];
            s.push({ name: o, score: score, time: runTimer }),
              s.sort((e, t) => t.score - e.score),
              s.length > 10 && (s = s.slice(0, 10)),
              localStorage.setItem(key, JSON.stringify(s)),
              (t.textContent = "Pontuação enviada!"),
              (t.className = ""),
              (d.getElementById("score-submission").style.display = "none"),
              this.loadAndDisplayScores("leaderboard-list");
            this.loadAndDisplayScores("leaderboard-list-main", true);
          } catch (i) {
            (t.textContent = "Falha ao enviar pontuação."),
              (t.className = "error"),
              (d.getElementById("submitScoreBtn").disabled = !1),
              console.error(i);
          }
        },
        clearScores() {
          if (
            confirm(
              `Limpar placar para dificuldade "${this.currentDifficulty}"?`
            )
          ) {
            try {
              localStorage.removeItem(this.getLeaderboardKey());
              this.loadAndDisplayScores("leaderboard-list-main", true);
              this.loadAndDisplayScores("leaderboard-list");
            } catch (e) {
              console.error(e);
            }
          }
        },
      };
      let thunderboltTimer = 0;
      const THUNDERBOLT_COOLDOWN = 5e3;
      function handleThunderbolts(e) {
        if (
          player.stats.thunderboltCount > 0 &&
          ((thunderboltTimer += e), thunderboltTimer >= 5e3)
        ) {
          thunderboltTimer = 0;
          for (let t = 0; t < player.stats.thunderboltCount; t++) {
            let o = Math.random() * canvas.width;
            if (enemies.length > 0) {
              const i = enemies[Math.floor(Math.random() * enemies.length)];
              o = i.x + i.width / 2;
            }
            const i = player.stats.projectileDamage;
            const groundY = getGroundHeight(o);

            lightningBolts.push(new LightningBolt(o, groundY));

            createExplosion(o, groundY, "#00ffff", 30);

            enemies.forEach((e) => {
              Math.abs(e.x + e.width / 2 - o) < 25 && e.takeDamage(i, !0);
            });
          }
        }
      }
      function checkCollision(e, t) {
        return (
          e.x < t.x + t.width &&
          e.x + e.width > t.x &&
          e.y < t.y + t.height &&
          e.y + e.height > t.y
        );
      }

      function isEnemyIntersectedByRay(enemy, rayStartX, rayStartY, rayAngle) {
        const dirX = Math.cos(rayAngle);
        const dirY = Math.sin(rayAngle);

        if (Math.abs(dirX) < 0.0001) {
          if (rayStartX < enemy.x || rayStartX > enemy.x + enemy.width)
            return false;
          if (dirY > 0) return rayStartY < enemy.y + enemy.height;
          return rayStartY > enemy.y;
        }
        if (Math.abs(dirY) < 0.0001) {
          if (rayStartY < enemy.y || rayStartY > enemy.y + enemy.height)
            return false;
          if (dirX > 0) return rayStartX < enemy.x + enemy.width;
          return rayStartX > enemy.x;
        }

        const invDirX = 1 / dirX;
        const invDirY = 1 / dirY;

        let t1 = (enemy.x - rayStartX) * invDirX;
        let t2 = (enemy.x + enemy.width - rayStartX) * invDirX;
        let t3 = (enemy.y - rayStartY) * invDirY;
        let t4 = (enemy.y + enemy.height - rayStartY) * invDirY;

        let tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        let tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));

        if (tmax < 0) return false;
        if (tmin > tmax) return false;

        return true;
      }
      function getRarityPool() {
        const e = Math.random(),
          t = 0.1 + 0.5 * player.stats.luck,
          o = 0.3 + player.stats.luck;
        return e < t ? "rare" : e < t + o ? "uncommon" : "common";
      }
      function triggerLevelUp() {
        const l = d.getElementById("levelUpFlash");
        l.classList.add("active"),
          (l.onanimationend = () => l.classList.remove("active")),
          (gameState = "levelUp"),
          (levelUpScreen.style.display = "flex"),
          (d.getElementById("autofire-indicator").style.display = "none"),
          (upgradeCardsContainer.innerHTML = "");
        let e = [];
        const t = player.stats.upgradeChoices,
          o = availableUpgrades.filter(
            (item) =>
              !(item.name === "Gêmeo Espectral" && player.stats.hasWisp) &&
              !(item.name === "Vontade Inquebrável" && player.stats.revives > 0)
          );
        for (let i = 0; i < t; i++) {
          let s = getRarityPool(),
            n = o.filter(
              (upgradeDef) =>
                upgradeDef.rarity === s &&
                !e.find(
                  (existingUpgrade) => existingUpgrade.name === upgradeDef.name
                )
            );
          if (0 === n.length) {
            n = o.filter(
              (upgradeDef) =>
                !e.find(
                  (existingUpgrade) => existingUpgrade.name === upgradeDef.name
                )
            );
          }
          if (n.length > 0) {
            e.push(n[Math.floor(Math.random() * n.length)]);
          }
        }
        e.forEach((u) => {
          if (!u) return;
          const cardDiv = d.createElement("div");
          const raritiesText = {
            common: "comum",
            uncommon: "incomum",
            rare: "raro",
          };
          const iconHTML =
            u.icon && spriteImages[u.icon]
              ? `<div class="card-icon"><img src="${
                  spriteImages[u.icon].src
                }" alt="${u.name}"></div>`
              : '<div class="card-icon"></div>';

          let cardTitle = u.name;
          let descriptionText = u.description;

          const currentUpgradeLevel = player.upgrades.get(u.name) || 0;
          if (
            currentUpgradeLevel > 0 &&
            !u.isUnique &&
            typeof u.generatesNextLevelDescription === "function"
          ) {
            cardTitle = `${u.name} (Nível ${currentUpgradeLevel + 1})`;
            descriptionText = u.generatesNextLevelDescription(
              player.stats,
              currentUpgradeLevel,
              player
            );
          } else if (
            typeof u.generatesNextLevelDescription === "function" &&
            (!u.isUnique || u.name === "Pulso Restaurador")
          ) {
            descriptionText = u.generatesNextLevelDescription(
              player.stats,
              0,
              player
            );
          }

          cardDiv.className = `upgrade-card rarity-${u.rarity}`;
          cardDiv.innerHTML = `
                ${iconHTML}
                <div class="card-header">
                    <h3>${cardTitle}</h3>
                    <div class="card-rarity">${raritiesText[u.rarity]}</div>
                </div>
                <div class="card-divider"></div>
                <p class="card-description">${descriptionText}</p>`;

          cardDiv.onclick = () => selectUpgrade(u);
          upgradeCardsContainer.appendChild(cardDiv);
        });

        (rerollButton.innerHTML = `<img src="img/dado.png" style="vertical-align: middle; width: 22px; height: 22px; margin-right: 8px;"> Rerolar (${player.rerollsLeft} restante(s))`),
          (rerollButton.disabled = player.rerollsLeft <= 0);
      }
      function selectUpgrade(e) {
        soundManager.playUIClickSound(),
          player.stats.tome && "common" === e.rarity
            ? e.apply(player)
            : e.apply(player),
          e.isUnique &&
            (availableUpgrades = availableUpgrades.filter(
              (t) => t.name !== e.name
            ));
        const t = player.upgrades.get(e.name) || 0;
        player.upgrades.set(e.name, t + 1),
          updateInventoryUI(),
          (gameState = "playing"),
          (levelUpScreen.style.display = "none"),
          (player.isLevelingUp = false),
          (d.getElementById("right-ui-container").style.opacity =
            gameData.showInventory ? "0.7" : "0"),
          updateAutofireIndicator(),
          (lastTime = performance.now()),
          requestAnimationFrame(gameLoop);
      }
      rerollButton.onclick = () => {
        if (player.rerollsLeft > 0) {
          soundManager.playDiceRollSound();
          player.rerollsLeft--;
          triggerLevelUp();
        }
      };
      class LightningBolt {
        constructor(startX, endY) {
          this.path = [];
          this.life = 15;
          let currentX = startX;
          let currentY = 0;
          this.path.push({ x: currentX, y: currentY });

          while (currentY < endY) {
            currentX += Math.random() * 30 - 15;
            currentY += Math.random() * 20 + 10;
            this.path.push({ x: currentX, y: Math.min(currentY, endY) });
          }
        }

        update() {
          this.life--;
        }

        draw() {
          ctx.save();
          ctx.strokeStyle = `rgba(200, 255, 255, ${(this.life / 15) * 0.9})`;
          ctx.lineWidth = 4;
          ctx.shadowColor = "#00ffff";
          ctx.shadowBlur = 20;

          ctx.beginPath();
          ctx.moveTo(this.path[0].x, this.path[0].y);
          for (let i = 1; i < this.path.length; i++) {
            ctx.lineTo(this.path[i].x, this.path[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
      }
      function drawGround() {
        if (groundSegments.length === 0) return;
        (ctx.fillStyle = currentGroundColor),
          ctx.beginPath(),
          ctx.moveTo(0, canvas.height),
          ctx.lineTo(0, groundSegments[0].y);
        for (const e of groundSegments) ctx.lineTo(e.x + e.width, e.y);
        ctx.lineTo(canvas.width, canvas.height),
          ctx.closePath(),
          ctx.fill(),
          (ctx.strokeStyle = currentGroundStrokeColor),
          (ctx.lineWidth = 2.5),
          ctx.beginPath(),
          ctx.moveTo(0, groundSegments[0].y);
        for (const e of groundSegments) ctx.lineTo(e.x + e.width, e.y);
        ctx.stroke();
      }
      function generatePlatforms() {
        platforms.length = 0;
        platforms.push({
          x: canvas.width - 450,
          y: canvas.height - 300,
          width: 250,
          height: 25,
        });
      }
      function drawPlatforms() {
        ctx.fillStyle = currentGroundColor;
        ctx.strokeStyle = currentGroundStrokeColor;
        ctx.lineWidth = 2.5;
        platforms.forEach((p) => {
          ctx.beginPath();
          ctx.rect(p.x, p.y, p.width, p.height);
          ctx.fill();
          ctx.stroke();
        });
      }
      let lastTime = 0;
      function updateInventoryVisibility() {
        d.getElementById("right-ui-container").style.display =
          gameData.showInventory ? "block" : "none";
      }
      function gameLoop(e) {
        if ("playing" !== gameState && "transitioning" !== gameState) {
          if (gameState === "gameOver" || gameState === "victory") {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            Starfield.draw();
            drawGround();
            drawPlatforms();
            [particles, orbs, pProjs, eProjs, enemies].forEach((item) =>
              item.forEach((i) => i.draw())
            );
            wisp && wisp.draw();
            player.draw();
            dNums.forEach((dn) => dn.draw());
          }
          updateInventoryVisibility();
          const t = Math.min(50, e - lastTime);
          return;
        }
        const t = Math.min(50, e - lastTime);
        (lastTime = e),
          (gameTime += t),
          (runTimer += t),
          player.update(t),
          wisp && wisp.update(t),
          Starfield.update(gameData.parallaxEnabled ? player.vx : 0),
          updateWaveSystem(t);
        handleThunderbolts(t);
        [
          enemies,
          pProjs,
          eProjs,
          particles,
          orbs,
          dNums,
          lightningBolts,
        ].forEach((arr) => arr.forEach((item) => item.update(t)));
        pProjs.forEach((e) =>
          enemies.forEach((t) => {
            e.active &&
              t.hp > 0 &&
              checkCollision(
                {
                  x: e.x - e.radius,
                  y: e.y - e.radius,
                  width: 2 * e.radius,
                  height: 2 * e.radius,
                },
                t
              ) &&
              e.onHit(t);
          })
        ),
          eProjs.forEach((e) => {
            e.active &&
              checkCollision(
                {
                  x: e.x - e.radius,
                  y: e.y - e.radius,
                  width: 2 * e.radius,
                  height: 2 * e.radius,
                },
                player
              ) &&
              (player.takeDamage(e.damage), (e.active = !1));
          }),
          (enemies = enemies.filter((e) => e.hp > 0)),
          (pProjs = pProjs.filter((e) => e.active)),
          (eProjs = eProjs.filter((e) => e.active)),
          (particles = particles.filter((e) => e.life > 0)),
          (orbs = orbs.filter((o) => o.life > 0)),
          (dNums = dNums.filter((e) => e.life > 0)),
          (lightningBolts = lightningBolts.filter((lb) => lb.life > 0)),
          ctx.clearRect(0, 0, canvas.width, canvas.height),
          Starfield.draw(),
          drawGround(),
          drawPlatforms(),
          [particles, orbs, pProjs, eProjs, enemies].forEach((arr) =>
            arr.forEach((item) => item.draw())
          );
        wisp && wisp.draw(),
          player.draw(),
          lightningBolts.forEach((lb) => lb.draw()),
          dNums.forEach((e) => e.draw());
        const expPercent = (player.exp / player.expToNextLevel) * 100;
        d.getElementById("exp-bar").style.width = `${expPercent}%`;
        d.getElementById("exp-bar-text").innerText = `${Math.floor(
          player.exp
        )}/${player.expToNextLevel} (${expPercent.toFixed(0)}%)`;

        (d.getElementById("score-text").innerText = `Placar: ${score}`),
          (d.getElementById(
            "game-info-text"
          ).innerText = `LVL ${player.level} | Onda ${currentWave}`),
          (d.getElementById("timer-text").innerText = `Tempo: ${formatTime(
            runTimer
          )}`),
          (d.getElementById("enemy-count-text").innerText =
            waveState === "fighting"
              ? `Inimigos: ${enemies.length}/${totalEnemiesThisWave}`
              : `Próxima Onda...`);
        requestAnimationFrame(gameLoop);
      }
      function resetGame() {
        (keys = {}),
          (gameTime = 0),
          (score = 0),
          (runSouls = 0),
          (runTimer = 0),
          (runEnemiesKilled = 0),
          (infiniteModeActive = false),
          (lightningBolts = []),
          (autoFire = !1),
          (enemies = []),
          (pProjs = []),
          (eProjs = []),
          (particles = []),
          (orbs = []),
          (dNums = []),
          (wisp = null),
          (platforms = []),
          (availableUpgrades = [...allUpgrades]),
          (currentGroundColor = "#1a1a2a");
        currentGroundStrokeColor = "#9b59b6";
        currentStarfieldConfig = 0;

        generateGround(),
          generatePlatforms(),
          Starfield.init(),
          (player = new Player()),
          (player.isLevelingUp = false),
          updateInventoryUI(),
          (d.getElementById("right-ui-container").style.opacity =
            gameData.showInventory ? "0.7" : "0"),
          updateAutofireIndicator(),
          (gameOverScreen.style.display = "none"),
          (pauseScreen.style.display = "none"),
          (d.getElementById("score-submission").style.display = "block"),
          (d.getElementById("playerNameInput").value = ""),
          (d.getElementById("submission-message").textContent = ""),
          (d.getElementById("submitScoreBtn").disabled = !1),
          (gameState = "playing"),
          (currentWave = 0),
          (waveState = "intermission"),
          (intermissionTimer = 1e3);
      }
      function togglePause() {
        "playing" === gameState
          ? ((gameState = "paused"), (pauseScreen.style.display = "flex"))
          : "paused" === gameState &&
            ((gameState = "playing"),
            (pauseScreen.style.display = "none"),
            (lastTime = performance.now()),
            requestAnimationFrame(gameLoop));
      }
      function updateToggleButton(e, t, o, i) {
        e.innerText = `${o}: ${t ? i[0] : i[1]}`;
      }
      function toggleAndSave(e, t) {
        (gameData[e] = !gameData[e]),
          soundManager.playUIClickSound(),
          t(),
          saveGameData();
      }
      function updateAllToggleButtons() {
        updateToggleButton(soundToggle, gameData.soundEnabled, "Som", [
          "LIGADO",
          "DESLIGADO",
        ]),
          updateToggleButton(aimLineToggle, gameData.aimLineEnabled, "Mira", [
            "LIGADA",
            "DESLIGADA",
          ]),
          updateToggleButton(hitboxToggle, gameData.showHitboxes, "Hitbox", [
            "LIGADO",
            "DESLIGADO",
          ]),
          updateToggleButton(
            enemyHealthToggle,
            gameData.showEnemyHealthBars,
            "Barras HP",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(
            damageNumbersToggle,
            gameData.showDamageNumbers,
            "Nº Dano",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(
            parallaxToggle,
            gameData.parallaxEnabled,
            "Parallax",
            ["LIGADO", "DESLIGADO"]
          ),
          updateToggleButton(
            inventoryToggle,
            gameData.showInventory,
            "Power Ups",
            ["LIGADO", "DESLIGADO"]
          );
      }
      function startGameSequence() {
        soundManager.playUIClickSound(),
          resetGame(),
          (lastTime = performance.now()),
          requestAnimationFrame(gameLoop),
          setTimeout(() => {
            d.getElementById("controls-guide").style.display = "none";
          }, 2e3);
      }
      function loadAssets(e) {
        const t = new Set();
        allUpgrades.forEach((e) => {
          e.icon
            ? t.add(e.icon)
            : "common" === e.rarity
            ? t.add("common.png")
            : "uncommon" === e.rarity
            ? t.add("uncommon.png")
            : t.add("rare.png");
        }),
          t.add("hat_bruxo.png"),
          t.add("hat_guerreiro.png"),
          t.add("hat_ladino.png"),
          t.add("alma.png"),
          t.add("corpo.png"),
          t.add("wpn_staff.png"),
          t.add("inimigo1.png"),
          t.add("inimigo2.png"),
          t.add("inimigo3.png");
        t.add("dado.png");
        const o = Array.from(t);
        let i = 0;
        if (0 === o.length) return void e();
        if (goToDifficultyButton) {
          goToDifficultyButton.innerText = "Carregando...";
          goToDifficultyButton.disabled = true;
        }

        o.forEach((t) => {
          const s = new Image();
          (s.src = `img/${t}`),
            (spriteImages[t] = s),
            (s.onload = () => {
              i++;
              if (i === o.length) {
                if (goToDifficultyButton) {
                  goToDifficultyButton.innerText = "Iniciar Jogo";
                  goToDifficultyButton.disabled = false;
                }
                e();
              }
            }),
            (s.onerror = () => {
              console.error(`Erro ao carregar: img/${t}`);
              i++;
              if (i === o.length) {
                if (goToDifficultyButton) {
                  goToDifficultyButton.innerText = "Iniciar Jogo";
                  goToDifficultyButton.disabled = false;
                }
                e();
              }
            });
        });
      }
      const switchScreen = (e, t, o) => {
        e && (e.style.display = "none"),
          t && (d.getElementById(t).style.display = "flex"),
          o && (gameState = o);
      };
      function populateWiki(filter = "") {
        const container = d.getElementById("wikiListContainer");
        container.innerHTML = "";
        const rarityOrder = { common: 1, uncommon: 2, rare: 3 };
        const sortedUpgrades = [...allUpgrades].sort(
          (a, b) => rarityOrder[a.rarity] - rarityOrder[b.rarity]
        );

        const lowerCaseFilter = filter.toLowerCase();

        sortedUpgrades
          .filter(
            (u) =>
              u.name.toLowerCase().includes(lowerCaseFilter) ||
              u.rarity.toLowerCase().includes(lowerCaseFilter) ||
              u.description.toLowerCase().includes(lowerCaseFilter)
          )
          .forEach((u) => {
            const itemDiv = d.createElement("div");
            itemDiv.className = "wiki-item";
            const icon = u.icon
              ? `<img src="img/${u.icon}" style="width: 24px; height: 24px; image-rendering: pixelated;">`
              : "";
            itemDiv.innerHTML = `
              <h3>${icon} ${u.name} <span class="rarity rarity-${
              u.rarity
            }" style="color: ${
              { common: "#fff", uncommon: "#3498db", rare: "#9b59b6" }[u.rarity]
            }">${u.rarity}</span></h3>
              <p>${u.description}</p>
            `;
            container.appendChild(itemDiv);
          });
      }
      function setupEventListeners() {
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());
        window.addEventListener("keydown", (e) => {
          keys[e.key] = !0;

          if (
            e.key === "Alt" ||
            e.key === "Tab" ||
            e.key === "Control" ||
            e.key === "Shift"
          ) {
            e.preventDefault();
          }

          if (e.key === "Escape") {
            e.preventDefault();

            if (optionsScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(optionsScreen, optionsReturnScreen);
              return;
            }
            if (leaderboardScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(leaderboardScreen, leaderboardReturnScreen);
              return;
            }
            if (wikiScreen.style.display === "flex") {
              soundManager.playUIClickSound();
              switchScreen(wikiScreen, wikiReturnScreen);
              return;
            }

            if (gameState === "playing" || gameState === "paused") {
              togglePause();
            }
            return;
          }

          if ("q" === e.key || "Q" === e.key) {
            gameData.showInventory = !gameData.showInventory;
            updateAllToggleButtons();
            updateInventoryVisibility();
            return;
          }

          const t = d.getElementById("controls-guide");
          if ("u" === e.key || "U" === e.key) {
            t.style.display = "none" === t.style.display ? "block" : "none";
          } else if (gameState === "playing") {
            if (" " === e.key || "Space" === e.code) {
              e.preventDefault(), player.jump();
            } else if ("r" === e.key || "R" === e.key) {
              (autoFire = !autoFire), updateAutofireIndicator();
            }
          }
        }),
          window.addEventListener("keyup", (e) => {
            keys[e.key] = !1;
          }),
          window.addEventListener("mousemove", (e) => {
            (mouse.x = e.clientX), (mouse.y = e.clientY);
          }),
          window.addEventListener("mousedown", (e) => {
            0 === e.button && (mouse.down = !0);
          }),
          window.addEventListener("mouseup", (e) => {
            0 === e.button && (mouse.down = !1);
          });
        restartButton.addEventListener("click", startGameSequence),
          restartFromPauseButton.addEventListener("click", startGameSequence),
          resumeButton.addEventListener("click", () => {
            soundManager.playUIClickSound(), togglePause();
          }),
          splashHatShopButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              HAT_SHOP.init("splashHatShopContainer", "splashSoulCount"),
              switchScreen(splashScreen, "splashHatShopScreen");
          }),
          splashHatShopBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(splashHatShopScreen, "splashScreen");
          }),
          soundToggle.addEventListener("click", () =>
            toggleAndSave("soundEnabled", updateAllToggleButtons)
          ),
          aimLineToggle.addEventListener("click", () =>
            toggleAndSave("aimLineEnabled", updateAllToggleButtons)
          ),
          hitboxToggle.addEventListener("click", () =>
            toggleAndSave("showHitboxes", updateAllToggleButtons)
          ),
          enemyHealthToggle.addEventListener("click", () =>
            toggleAndSave("showEnemyHealthBars", updateAllToggleButtons)
          ),
          damageNumbersToggle.addEventListener("click", () =>
            toggleAndSave("showDamageNumbers", updateAllToggleButtons)
          ),
          parallaxToggle.addEventListener("click", () =>
            toggleAndSave("parallaxEnabled", updateAllToggleButtons)
          ),
          inventoryToggle.addEventListener("click", () =>
            toggleAndSave("showInventory", updateAllToggleButtons)
          ),
          splashOptionsButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (optionsReturnScreen = "splashScreen"),
              switchScreen(splashScreen, "optionsScreen");
          }),
          splashDebugButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(splashScreen, "debugScreen");
          }),
          pauseOptionsButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (optionsReturnScreen = "pauseScreen"),
              switchScreen(pauseScreen, "optionsScreen");
          }),
          optionsBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(optionsScreen, optionsReturnScreen);
          }),
          debugBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(debugScreen, "splashScreen");
          }),
          d
            .getElementById("submitScoreBtn")
            .addEventListener("click", () => Leaderboard.submitScore()),
          d.getElementById("backToMenuButton").addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(gameOverScreen, "splashScreen", "splash");
          }),
          d
            .getElementById("pauseBackToMenuButton")
            .addEventListener("click", () => {
              soundManager.playUIClickSound(),
                switchScreen(pauseScreen, "splashScreen", "splash");
            }),
          splashLeaderboardButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (leaderboardReturnScreen = "splashScreen"),
              switchScreen(splashScreen, "leaderboardScreen"),
              Leaderboard.loadAndDisplayScores("leaderboard-list-main");
          }),
          pauseLeaderboardButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              (leaderboardReturnScreen = "pauseScreen"),
              switchScreen(pauseScreen, "leaderboardScreen"),
              Leaderboard.loadAndDisplayScores("leaderboard-list-main");
          }),
          leaderboardBackButton.addEventListener("click", () => {
            soundManager.playUIClickSound(),
              switchScreen(leaderboardScreen, leaderboardReturnScreen);
          }),
          d
            .getElementById("clearLeaderboardButton")
            .addEventListener("click", () => {
              soundManager.playUIClickSound(), Leaderboard.clearScores();
            });

        d.getElementById("toggleInventoryButton").addEventListener(
          "click",
          () => {
            soundManager.playUIClickSound();
            const inventoryUI = d.getElementById("right-ui-container");
            if (inventoryUI.style.opacity === "0") {
              inventoryUI.style.opacity = "0.7";
              inventoryUI.style.zIndex = "52";
            } else {
              inventoryUI.style.opacity = "0";
              inventoryUI.style.zIndex = "10";
            }
          }
        );

        pauseShowControlsButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          const controlsGuide = d.getElementById("controls-guide");
          if (
            controlsGuide.style.display === "none" ||
            controlsGuide.style.display === ""
          ) {
            controlsGuide.style.display = "block";
            controlsGuide.style.zIndex = "51";
          } else {
            controlsGuide.style.display = "none";
            controlsGuide.style.zIndex = "9";
          }
        });

        d.getElementById("continueButton").addEventListener("click", () => {
          soundManager.playUIClickSound();
          infiniteModeActive = true;
          d.getElementById("victoryScreen").style.display = "none";
          gameState = "playing";
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
        });

        d.getElementById("endRunButton").addEventListener("click", () => {
          soundManager.playUIClickSound();
          d.getElementById("victoryScreen").style.display = "none";
          gameState = "gameOver";
          gameOverScreen.style.display = "flex";
          d.getElementById("gameOverTitle").innerText = "CORRIDA FINALIZADA";
          d.getElementById(
            "gameOverStats"
          ).innerHTML = `Pontuação Final: ${score}<br>Onda Concluída: ${currentWave}<br>Inimigos Derrotados: ${runEnemiesKilled}<br>Tempo: ${formatTime(
            runTimer
          )}`;
          Leaderboard.show();
          HAT_SHOP.init("gameOverHatShopContainer", "gameOverSoulCount");
        });

        splashWikiButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          wikiReturnScreen = "splashScreen";
          switchScreen(splashScreen, "wikiScreen");
        });

        pauseWikiButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          wikiReturnScreen = "pauseScreen";
          switchScreen(pauseScreen, "wikiScreen");
        });

        wikiBackButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          switchScreen(wikiScreen, wikiReturnScreen);
        });

        d.getElementById("wikiSearchBox").addEventListener("input", (e) => {
          populateWiki(e.target.value);
        });

        goToDifficultyButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          switchScreen(splashScreen, "difficultyScreen");
        });

        difficultyBackButton.addEventListener("click", () => {
          soundManager.playUIClickSound();
          switchScreen(difficultyScreen, "splashScreen");
        });

        function setDifficultyAndStart(
          difficultyName,
          threatMult,
          enemyScaleMult
        ) {
          selectedDifficultyName = difficultyName;
          difficultySettings.threatMultiplier = threatMult;
          difficultySettings.enemyScalingMultiplier = enemyScaleMult;
          soundManager.init();
          switchScreen(difficultyScreen, null, "playing");
          startGameSequence();
          Leaderboard.currentDifficulty = selectedDifficultyName;
          Leaderboard.show();
        }

        difficultyEasy.addEventListener("click", () => {
          setDifficultyAndStart("Fácil", 0.75, 0.8);
        });
        difficultyNormal.addEventListener("click", () => {
          setDifficultyAndStart("Normal", 1.0, 1.0);
        });
        difficultyHard.addEventListener("click", () => {
          setDifficultyAndStart("Difícil", 1.35, 1.2);
        });
      }

      function showVictoryScreen() {
        gameState = "victory";
        const statsDiv = d.getElementById("victoryStats");

        statsDiv.innerHTML = `
              <strong>Pontuação:</strong> ${score}<br>
              <strong>Inimigos Derrotados:</strong> ${runEnemiesKilled}<br>
              <strong>Tempo Total:</strong> ${formatTime(runTimer)}<br>
          `;
        d.getElementById("victoryScreen").style.display = "flex";
      }
      function resetProgress() {
        confirm(
          "Deseja mesmo resetar todo o progresso? Isso é irreversível."
        ) &&
          (soundManager.playUIClickSound(),
          localStorage.removeItem("voidSurvivorData"),
          localStorage.removeItem("voidSurvivorLeaderboard"),
          location.reload());
      }
      function unlockAllHats() {
        soundManager.playUIClickSound(),
          (gameData.unlockedHats = Object.keys(HATS)),
          saveGameData(),
          alert("Todas as classes foram liberadas!");
      }
      function updateAutofireIndicator() {
        const e = d.getElementById("autofire-indicator");
        if (e) {
          if (autoFire) {
            e.textContent = "AUTO: ON";
            e.classList.add("active");
            e.style.display = "block";
          } else {
            e.style.display = "none";
            e.classList.remove("active");
          }
        }
      }
      function updateInventoryUI() {
        const inventoryContainer = d.getElementById("upgrade-inventory");
        inventoryContainer.innerHTML = "";
        if (player && player.upgrades.size > 0) {
          for (const [name, count] of player.upgrades) {
            const itemDiv = d.createElement("div");
            itemDiv.className = "inventory-item";

            const upgradeData = allUpgrades.find((u) => u.name === name);
            let iconHtml = "";
            if (upgradeData && upgradeData.icon) {
              iconHtml = `<img src="img/${upgradeData.icon}" style="width: 18px; height: 18px; image-rendering: pixelated;">`;
            }

            itemDiv.innerHTML = `${iconHtml}<span>${name} (${count})</span>`;
            inventoryContainer.appendChild(itemDiv);
          }
        }
      }
      function init() {
        loadGameData(),
          updateAllToggleButtons(),
          populateWiki(),
          loadAssets(() => {
            d.getElementById("resetProgressButton");
            d
              .getElementById("resetProgressButton")
              .addEventListener("click", resetProgress),
              d
                .getElementById("unlockAllHatsButton")
                .addEventListener("click", unlockAllHats);
          }),
          setupEventListeners();
      }
      init();
    </script>
  </body>
</html>
